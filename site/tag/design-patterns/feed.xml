<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="http://localhost:4000/tag/design-patterns/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2022-05-12T16:02:32+09:00</updated>
  <id>http://localhost:4000/tag/design-patterns/feed.xml</id>

  
  
  

  
    <title type="html">PIGBEAN Tech blog | </title>
  

  
    <subtitle>Seize the day</subtitle>
  

  

  
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">MVVM 패턴과 AAC</title>
      <link href="http://localhost:4000/MVVM-%ED%8C%A8%ED%84%B4%EA%B3%BC-AAC" rel="alternate" type="text/html" title="MVVM 패턴과 AAC" />
      <published>2021-10-25T21:55:00+09:00</published>
      <updated>2021-10-25T21:55:00+09:00</updated>
      <id>http://localhost:4000/MVVM%20%ED%8C%A8%ED%84%B4%EA%B3%BC%20AAC</id>
      <content type="html" xml:base="http://localhost:4000/MVVM-%ED%8C%A8%ED%84%B4%EA%B3%BC-AAC">&lt;p&gt;이전 글에서 디자인 패턴 중 MVC 패턴을 다뤄보았다. 이번 글에서는 안드로이드 개발에서 더욱 선호되는 MVVM 패턴과 MVVM 패턴 적용을 더 쉽게 해주는 AAC에 대해서 살펴보려고 한다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;앱-아키텍쳐의-원칙&quot;&gt;앱 아키텍쳐의 원칙&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;안드로이드 앱에는 여러 앱 구성요소가 포함된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;액티비티 : 사용자와 상호작용하기 위한 진입점. (Activity)&lt;/li&gt;
  &lt;li&gt;서비스 : 백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점. (Service)&lt;/li&gt;
  &lt;li&gt;콘텐츠 제공자 : 파일 시스템, SQLite, 데이터베이스, 웹이나 앱이 액세스할 수 있는 저장 가능한 앱 데이터의
 공유 가능한 형태들을 관리한다. (ContentProvider)&lt;/li&gt;
  &lt;li&gt;브로드캐스트 수신자 : 시스템이 사용자 플로우 밖에서 이벤트를 앱에 전달하도록 지원하는 구성 요소.
 앱이 시스템 전체의 브로드캐스트 알림에 응답할 수 있도록 해준다.
 가 대표가 된다. (BroadcastReceiver)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;개발자는 앱 매니페스트에서 앱 구성요소의 대부분을 선언하고 안드로이드 OS에서는 매니페스트를 확인해서 기기의 사용자 환경에 앱을 통합하는 방법을 결정한다.&lt;/p&gt;

&lt;p&gt;휴대폰에서는 앱 실행 중 전화가 오거나, 램 공간이 부족해서 OS에서 새로운 앱 실행을 위해 일부 앱을 강제 종료 시킬 수 있다.
이러한 환경 조건을 고려해 볼 때 앱 구성요소는 개별적이고 비순차적으로 실행될 수 있고, 운영체제나 사용자가 언제든지 앱 구성요소를 제거할 수 있게 되는데, 이런 경우들은 직접 제어할 수 없기 때문에&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;앱 구성요소에 데이터나 상태를 저장해서는 안되며,&lt;/li&gt;
  &lt;li&gt;앱 구성요소가 서로 종속되어서는 안된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 아래의 아키텍쳐 원칙이 제안되고 있다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h3 id=&quot;관심사-분리&quot;&gt;관심사 분리&lt;/h3&gt;

&lt;p&gt;코드를 작성할 때 Activity나 Fragment와 같은 UI 기반의 클래스는 UI 및 OS 상호작용을 처리하는 로집만 포함해야 한다. 이는 UI 클래스를 최대한 가볍게 유지하여 Lifecycle 관련 문제를 피하기 위함이다.&lt;/p&gt;

&lt;p&gt;UI 클래스는 무언가를 소유하는 것이 아닌 구현된 앱의 내용을 띄워주는 클래스 일 뿐이며 따라서 OS는 메모리 부족과 같은 특정한 상황이 발생되면 언제든지 UI 클래스를 제거할 수 있다. (제거하더라도 앱 기반이 되는 내용이 복구가 되면 &lt;strong&gt;UI클래스는 단지 내용을 띄우는 수단에 불구하기 때문에&lt;/strong&gt; 같은 내용이 화면에 표시될 수 있다.)&lt;/p&gt;

&lt;p&gt;따라서 UI 클래스로부터 UI, OS 상호작용을 제외한 다은 로직을 분리하여 UI 클래스에 대한 의존성을 최소화하는 것이 앱 관리 측면에서 좋다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h3 id=&quot;모델에서-ui-도출&quot;&gt;모델에서 UI 도출&lt;/h3&gt;

&lt;p&gt;UI는 Model에서 만들어져야 한다. Model은 앱의 데이터 처리를 담당하는 컴포넌트로, 앱의 View 객체 및 앱 컴포넌트와 독립되어 있으므로 앱의 Lifecycle에 영향을 받지 않는다.
(네트워크가 끊어져도 앱이 죽지 않고, 메모리 확보를 위해 앱이 강제종료되어도 데이터가 살아있는 앱)
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;mvvm-개요&quot;&gt;MVVM 개요&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;이런 앱 아키텍쳐의 원칙에 따라 &lt;strong&gt;MVC 패턴의 단점을 보완&lt;/strong&gt;하고자 등장한 디자인 패턴이 바로 &lt;strong&gt;MVVM&lt;/strong&gt; 이다. &lt;strong&gt;MVVM&lt;/strong&gt; 은 기존 MVC 에서처럼 &lt;strong&gt;Controller 에게 막중한 역할을 부여하기보다,&lt;/strong&gt; 이 &lt;strong&gt;동작 자체를 분리하여&lt;/strong&gt; 동작의 흐름을 더욱 &lt;strong&gt;체계적으로 만들어주고 유지보수를 편리하게&lt;/strong&gt; 할 수 있도록 해주는 디자인 패턴이다.
&lt;strong&gt;MVVM 은 Model, View, ViewModel&lt;/strong&gt; 로 이루어져 있다. 대충 이름으로 구성을 파악해보면 MVC 패턴이 Model, View, Controller로 이루어져 있던 것과 비교하여 MVVM 패턴에서는 Controller가 사라지고 대신 ViewModel이 생겼다. 그렇다고 ViewModel이 Controller의 역할을 가져갔다고 볼 순 없고, Controller의 역할이 축소되며 View와 통합되었고 ViewModel이 새롭게 등장하였다고 이해하는 게 좋다.&lt;/p&gt;

&lt;p&gt;MVC 패턴과 비교하여 MVVM 패턴을 자세히 살펴보자. 아래 이미지는 이해하기 좋아서 https://aonee.tistory.com/48 에서 가져왔다.&lt;/p&gt;

&lt;div style=&quot;text-align: left&quot;&gt;
   &lt;img src=&quot;/assets/img/post_images/mvvm1.png&quot; width=&quot;100%&quot; /&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용자의 Action을 받는 곳&lt;/li&gt;
      &lt;li&gt;Activity/Fragment가 View의 역할&lt;/li&gt;
      &lt;li&gt;ViewModel의 데이터를 관찰하여 UI 갱신&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ViewModel&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;View의 데이터 요청을 Model로 전달&lt;/li&gt;
      &lt;li&gt;Model이 전달해주는 데이터를 받음&lt;/li&gt;
      &lt;li&gt;View에서는 ViewModel을 알고 있지만, ViewModel은 View를 알지 못함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;앱의 데이터 처리를 담당&lt;/li&gt;
      &lt;li&gt;ViewModel이 요청한 데이터를 반환&lt;/li&gt;
      &lt;li&gt;Room, Realm 등의 DB 사용이나 Retrofit을 통한 백엔드 API 호출(네트워킹)이 보편적으로 이루어짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ViewModel은 View와 Model 사이에서 데이터를 관리하고 바인딩해주는 요소이다. View가 원하는 데이터를 ViewModel이 들고있는데 따라서 View에서 ViewModel가 가지고 있는 데이터를 관찰(Observing)한다. 이를 통해 View가 데이터에 직접 접근하는 것이 아니라 UI 업데이트에만 집중할 수 있다.&lt;/p&gt;

&lt;p&gt;일반적으로 ViewModel과 View는 1:n의 관계이다. 따라서 View는 자신이 이용할 ViewModel을 선택하여 상태 변화 알림을 받게 된다. ViewModel은 View가 쉽게 사용할 수 있도록 Model의 데이터를 가공하여 View에게 제공한다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;aac&quot;&gt;AAC&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;MVVM 패턴은 많은 장점이 있지만 초보자가 쉽게 사용하기 다소 어렵다. 따러서 MVVM 패턴이 진입 장벽이 크다는 문제를 해결하기 위해서 구글에서 AAC라는 것을 제공한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;AAC&lt;/strong&gt;(Android Architecture Components)는 테스트와 유지보수가 쉬운 앱을 디자인할 수 있도록 돕는 라이브러리의 모음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_images/mvvm3.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구조도를 확인하면 각 구성요소가 아래 계층의 구성요소에만 종속됨을 알 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Activity / Fragment -&amp;gt; ViewModel&lt;/li&gt;
  &lt;li&gt;ViewModel -&amp;gt; Repository,&lt;/li&gt;
  &lt;li&gt;Repository는 유일하게 여러 다른 클래스에 종속되는데, Local DB(Room) / Server DB(Retrofit)에 종속된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 ViewModel에 어디에서 가져온 데이터든지 일관성있는 데이터를 제공해주기 위함이다. 위와 같이 설계할 경우 네트워크 연결과 관계없이, 얼마나 오랜만에 앱을 켰든지간에 앱에서는 Room DB에 저장해놓았던 데이터를 통해 UI를 미리 표시해준다. 그리고 이 데이터가 오래된 경우에는 Repository를 통해 데이터를 Update하게된다.&lt;/p&gt;

&lt;p&gt;이제 AAC의 각 구성요소를 자세히 확인해보자.&lt;/p&gt;

&lt;h3 id=&quot;view&quot;&gt;View&lt;/h3&gt;

&lt;p&gt;UI Controller을 담당하는 Activity, Fragment이다. 화면에 무엇을 그릴 지 결정하고, 사용자와 상호작용한다. 데이터의 변화를 감지하기 위한 옵저버를 가지고 있다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h3 id=&quot;viewmodel&quot;&gt;ViewModel&lt;/h3&gt;

&lt;p&gt;ViewModel은 앱의 Lifecycle을 고려하여 &lt;strong&gt;UI 관련 데이터를 저장하고 관리하는 컴포넌트&lt;/strong&gt;이다. AAC의 ViewModel은 안드로이드에서 자체적으로 &lt;strong&gt;안드로이드의 생명주기를 고려해서&lt;/strong&gt; 만든 ViewModel로, MVVM에서의 ViewModel과는 전혀 다른 개념이다. Activity/Fragment 당 하나의 ViewModel만 생성 가능하다. 다음 그림을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_images/mvvm2.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 메모리 누수, 화면 회전과 같은 상황에서도 Data를 잘 저장할 수 있다.
UI Controller로부터 UI 관련 데이터 저장 및 관리를 분리하여 ViewModel이 담당하도록 하면 다음과 같은 문제를 해결할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;안드로이드 프레임워크는 특정 작업이나 완전히 통제할 수 없는 기기 이벤트에 대한 응답으로 UI Controller를 제거하거나 다시 만들 수 있는데, 이런 경우 &lt;strong&gt;UI Controller에 저장된 모든 일시적인 UI 관련 데이터가 삭제&lt;/strong&gt;된다. 단순한 데이터의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSaveInstanceState()&lt;/code&gt; 메서드를 사용하여 복구할 수 있지만 대용량의 데이터의 경우엔 불가능하다.&lt;/li&gt;
  &lt;li&gt;UI Controller에서 데이터를 위한 비동기 호출을 한다면 &lt;strong&gt;메모리 누수 가능성을 방지하기 위한 많은 유지 관리&lt;/strong&gt;가 필요하며, 위에서와 같이 데이터를 복귀해야 하는 경우 &lt;strong&gt;비동기 호출을 다시해야 해서 리소스가 낭비&lt;/strong&gt;된다.&lt;/li&gt;
  &lt;li&gt;UI Controller에서 DB나 네트워크로부터 데이터를 로드하도록 하면 구분된 다른 클래스로 역할이 분담되지 않고 단일 클래스가 혼자서 앱의 모든 작업을 처리하려고 할 수 있다. 이 경우 &lt;strong&gt;테스트가 훨씬 더 어려워진다.&lt;/strong&gt;
&lt;br /&gt;
 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;live-data&quot;&gt;Live Data&lt;/h3&gt;

&lt;p&gt;LiveData는 &lt;strong&gt;식별 가능한 데이터 홀더 클래스&lt;/strong&gt;로 다른 앱 컴포넌트의 Lifecycle을 인식하며, 이를 통해 &lt;strong&gt;활성 상태에 있는 앱 컴포넌트 옵저버에게만 업데이트 정보를 알린다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LiveData를 사용하면 다음과 같은 이점이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;UI와 데이터 상태의 일치 보장&lt;/strong&gt;: LiveData는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer Pattern&lt;/code&gt;을 따르며 Lifecycle 상태가 변경될 때마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt; 객체에 알린다. 또 앱 데이터의 변경이 발생할 때마다 관찰자에게 알려 UI를 업데이트할 수 있도록 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 누수 없음&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt;는 Lifecycle 객체에 결합되어 있으며 연결된 객체의 Lifecycle이 끝나면 자동으로 삭제된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중지된 활동으로 인한 비정상 종료 없음&lt;/strong&gt;: 활동이 백 스택에 있을 때를 비롯하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt;가 비활성 상태에 있으면 어떤 LiveData 이벤트도 받지 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lifecycle을 더 이상 수동으로 처리하지 않음&lt;/strong&gt;: UI 컴포넌트는 관련 데이터를 관찰하기만 할 뿐 관찰을 중지하거나 다시 시작하지 않으며, LiveData가 이를 자동으로 관리한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최신 데이터 유지&lt;/strong&gt;: 컴포넌트가 비활성화되면 다시 활성화될 때 최신 데이터를 수신한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;적절한 구성 변경&lt;/strong&gt;: 기기 회전과 같은 구성 변경으로 인해 액티비티나 프래그먼트가 다시 생성되면 최신 데이터를 즉시 받게 된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;리소스 공유&lt;/strong&gt;: 앱에서 시스템 서비스를 공유할 수 있도록 싱글톤 패턴을 사용하는 LiveData 객체를 확장하여 시스템 서비스를 래핑할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LiveData 객체는 다음과 같은 순서로 사용된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; 클래스 내에서 특정 유형의 데이터를 보유할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;의 인스턴스를 만든다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onChanged()&lt;/code&gt; 메서드를 정의하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt; 객체를 UI Controller에 만든다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onChanged()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체가 보유한 데이터가 변경될 경우 발생하는 작업을 제어한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observe()&lt;/code&gt; 메서드를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt; 객체를 연결한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체를 업데이트하는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableLiveData&lt;/code&gt; 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setValue(T)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postValue(T)&lt;/code&gt; 메서드로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체에 저장된 값을 수정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;repository&quot;&gt;Repository&lt;/h3&gt;

&lt;p&gt;ViewModel과 상호작용하기 위해 잘 정리된 데이터 API를 들고 있는 클래스이다. 앱에 필요한 데이터 (내장 DB or 외부 DB)를 가져온다. ViewModel은 DB나 서버에 직접 접근하지 않고, Repository에 접근하는 것으로 앱의 데이터를 관리한다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h3 id=&quot;roomdatabase&quot;&gt;RoomDatabase&lt;/h3&gt;

&lt;p&gt;Room 라이브러리는 SQLite에 추상화 레이어를 제공하여 원활한 DB 액세스를 지원하고 SQLite를 완벽히 활용할 수 있게 하는 라이브러리이다. Room 라이브러리를 사용하면 앱을 실행하는 기기에서 앱 데이터의 캐시를 만들 수 있으며, 이 캐시를 통해 사용자는 인터넷 연결 여부와 관계없이 앱에 있는 주요 정보를 일관된 형태로 볼 수 있다. Room에 대해서는 다음 포스팅에서 더 자세히 설명할 예정이다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;mvvm-장단점&quot;&gt;MVVM 장단점&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;계속 데이터를 관찰하고 있기 때문에 UI 업데이트가 간편하다.&lt;/li&gt;
  &lt;li&gt;모듈화 되어 있어 유지보수에 용이하다.&lt;/li&gt;
  &lt;li&gt;View가 직접 Model에 접근하지 않아 Activity/Fragment 라이프 사이클에 의존하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아무래도 MVC 패턴보다는 처음 익숙해지는 데 시간이 많이 걸린다. (어렵다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;참고 내용 출처 :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kimyunseok.tistory.com/152&quot;&gt;https://kimyunseok.tistory.com/152&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@hwi\_chance/Android-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-AAC&quot;&gt;https://velog.io/@hwi_chance/Android-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-AAC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aonee.tistory.com/48&quot;&gt;https://aonee.tistory.com/48&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Beanie</name>
        
        
      </author>

      

      
        <category term="Design patterns" />
      
        <category term="MVVM" />
      
        <category term="AAC" />
      

      
        <summary type="html">이전 글에서 디자인 패턴 중 MVC 패턴을 다뤄보았다. 이번 글에서는 안드로이드 개발에서 더욱 선호되는 MVVM 패턴과 MVVM 패턴 적용을 더 쉽게 해주는 AAC에 대해서 살펴보려고 한다.   앱 아키텍쳐의 원칙  </summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">MVC 패턴</title>
      <link href="http://localhost:4000/MVC-%ED%8C%A8%ED%84%B4" rel="alternate" type="text/html" title="MVC 패턴" />
      <published>2021-10-21T21:55:00+09:00</published>
      <updated>2021-10-21T21:55:00+09:00</updated>
      <id>http://localhost:4000/MVC%20%ED%8C%A8%ED%84%B4</id>
      <content type="html" xml:base="http://localhost:4000/MVC-%ED%8C%A8%ED%84%B4">&lt;h2 id=&quot;디자인-패턴&quot;&gt;디자인 패턴&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;디자인 패턴은 소프트웨어 개발 시 어떠어떠한 구조로 코드를 짜면 &lt;strong&gt;개발의 효율성과 유지보수성, 운용성이 높아지며 프로그램의 최적화에 도움이 된다&lt;/strong&gt;는 것이 경험적으로 정립된 것이다. 디자인패턴에 대한 위키피디아의 설명은 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;소프트웨어 개발 방법에서 사용되는 디자인 패턴은, 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나로, 과거의 &lt;strong&gt;소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것&lt;/strong&gt;이다. 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식을 설명해 준다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4&quot;&gt;위키피디아&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앱 개발시 유명한 디자인 패턴으로는 MVC, MVVM, MVP 패턴이 있는 데 그 중 MVC, MVVM 패턴을 자세히 정리해보았다. 이번 글에서는 MVC 패턴을, 다음 글에서는 MVVM 패턴을 다뤄보고자 한다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;mvc-개요&quot;&gt;MVC 개요&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;MVC패턴의 MVC는 Model View Controller의 약자이다. 아래 그림은 MVC 패턴의 동작을 도식화 한 것이다.&lt;/p&gt;

&lt;div style=&quot;text-align: left&quot;&gt;
   &lt;img src=&quot;/assets/img/post_images/mvc1.png&quot; width=&quot;100%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;각각을 좀 더 자세히 살펴보자&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Model (Data)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;어플리케이션에 사용되는 데이터&lt;/li&gt;
      &lt;li&gt;View와 Controller에 묶이지 않아 재사용이 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용자가 보는 화면&lt;/li&gt;
      &lt;li&gt;유저가 화면에 어떤 입력(Action; 터치, 키보드 입력 등)을 하든 View는 어떻게 반응해야할지 모르며 Controller의 지시에 따라 행동함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;유저 입력 이벤트의 컨트롤타워&lt;/li&gt;
      &lt;li&gt;사용자가 어떤 입력을 할 경우 상황을 파악하고 화면 업데이트에 관한 지시를 내림&lt;/li&gt;
      &lt;li&gt;유저의 입력에 대해 Controller만이 반응하고, 이후 Controller가 View, Model과 소통하면서 지시를 내려 화면 변화를 이끌어냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 정의로만 봐서는 이해하기가 어렵다. 개인적으로는 실제 이벤트가 발생했을 때 각각이 어떻게 동작하는 것인지, 동작 순서를 따져봤을 때 이해가 훨씬 쉬웠다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;이벤트-발생시-mvc-동작-순서&quot;&gt;이벤트 발생시 MVC 동작 순서&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;div style=&quot;text-align: left&quot;&gt;
   &lt;img src=&quot;/assets/img/post_images/mvc2.png&quot; width=&quot;100%&quot; /&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Controller : 사용자 이벤트 발생&lt;/li&gt;
  &lt;li&gt;Controller : 사용자 이벤트 발생 후 Update가 필요한지 Model에 확인&lt;/li&gt;
  &lt;li&gt;Model : 데이터 Update가 필요한지 여부 판별&lt;/li&gt;
  &lt;li&gt;Model : Update가 필요한 경우 View에 알림&lt;/li&gt;
  &lt;li&gt;View : Model로부터 Update 이벤트 수신&lt;/li&gt;
  &lt;li&gt;View : Model에 필요한 데이터 요청&lt;/li&gt;
  &lt;li&gt;Model : 요청받은 데이터를 View에 전송&lt;/li&gt;
  &lt;li&gt;View : Model로부터 실제 필요한 데이터를 수신받아 View 갱신&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉, 어떠한 유저 입력이 발생하면 먼저 Controller가 상황을 파악하여 보이는 화면의 업데이트가 필요한지 Model을 통해 확인한다. Model은 업데이트 여부를 판별하여 업데이트가 필요할 경우 View에게 알리고, View는 또다시 Model에게 필요한 데이터를 요청한다. Model은 View가 필요하다고 요청한 데이터를 전송해주고, View는 이 데이터를 받아 갱신한다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;안드로이드에서의-mvc-패턴의-특징&quot;&gt;안드로이드에서의 MVC 패턴의 특징&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;웹에서 적용된 MVC는 View와 Control이 완전히 분리된 상태를 의미한다. 하지만 안드로이드에서는 특징적이게도 Activity 혹은 Fragment와 같은 View들이 View와 Control을 모두 가지고 있다. 이는 예시 코드를 보면 바로 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;예시 코드)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// View**&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;activity_main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;RecyclerView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recyclerView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findViewById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;rv_main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;recyclerView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setOnClickListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;OnClickListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Control**&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;SetContentView(R.layout.activity_main) -&amp;gt; View 관련된 메소드&lt;/li&gt;
  &lt;li&gt;recyclerView.setOnClickListener -&amp;gt; Control 관련된 메소드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 안드로이드에는 View와 Control이 함께 공존한다.&lt;/p&gt;

&lt;p&gt;따라서 위의 MVC 패턴의 동작순서는 안드로이드에서 아래와 같이 진행 될 것이다.&lt;/p&gt;
&lt;div style=&quot;text-align: left&quot;&gt;
   &lt;img src=&quot;/assets/img/post_images/mvc3.png&quot; width=&quot;100%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;따라서,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드에서는 Class 하나로 MVC 가 처리 가능한 구조로 만들어진다.&lt;/li&gt;
  &lt;li&gt;프로젝트가 커지고 메소드 숫자가 많아지면 코드 파악이 어려워진다.&lt;/li&gt;
  &lt;li&gt;메소드와 클래스를 적절히 분리하면서 복잡도를 관리해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;

&lt;h2 id=&quot;mvc-패턴의-장단점&quot;&gt;MVC 패턴의 장단점&lt;/h2&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;이런 MVC 패턴의 장단점을 정리하면 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;장점&lt;/th&gt;
      &lt;th&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;개발기간 감소&lt;br /&gt;: Activity 에서 모든 동작을 처리해주면 된다.&lt;/td&gt;
      &lt;td&gt;하나의 클래스에 코드양 증가&lt;br /&gt;: 액티비티 하나에서 모든 기능을 구현할 수 있기 때문에 코드양이 많아진다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;코드 분석 용이&lt;br /&gt;: 오히려 한 곳에 모여있기 때문에 가독성에 유리하다.&lt;/td&gt;
      &lt;td&gt;유지보수의 어려움&lt;br /&gt;: 코드 유지보수를 하다가 까딱했다간 &lt;strong&gt;UI 프레임 스킵 현상 및 메모리 릭 (Memory Leak)의 위험&lt;/strong&gt;에 빠질지도 모른다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;View와 Model의 결합도 상승&lt;br /&gt;: 대부분의 코드를 View에서 Model을 직접 호출하여 사용하기 때문에 결합도가 높아진다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;테스트코드 작성의 어려움&lt;br /&gt;: 작성한다 하더라도 UI 위주의 테스트 코드만 작성 가능하다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>Beanie</name>
        
        
      </author>

      

      
        <category term="Design patterns" />
      
        <category term="MVC" />
      

      
        <summary type="html">디자인 패턴  </summary>
      

      
      
    </entry>
  
</feed>
