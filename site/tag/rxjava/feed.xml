<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="http://localhost:4000/tag/rxjava/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2022-05-11T08:05:41+09:00</updated>
  <id>http://localhost:4000/tag/rxjava/feed.xml</id>

  
  
  

  
    <title type="html">PIGBEAN Tech blog | </title>
  

  
    <subtitle>Seize the day</subtitle>
  

  

  
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">RxJava(3) - Observable</title>
      <link href="http://localhost:4000/RxJava(3)-Observable" rel="alternate" type="text/html" title="RxJava(3) - Observable" />
      <published>2022-01-13T17:13:00+09:00</published>
      <updated>2022-01-13T17:13:00+09:00</updated>
      <id>http://localhost:4000/RxJava(3)%20-%20Observable</id>
      <content type="html" xml:base="http://localhost:4000/RxJava(3)-Observable">&lt;h2 id=&quot;observable-이란&quot;&gt;Observable 이란&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Observable은 RxJava의 가장 핵심적인 요소이다. Observable을 잘 이해하는 것은 RxJava를 활용하는 데 매우 중요하다. 옵저버 패턴의 정의는 다음과 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;옵저버 패턴(observer pattern) 은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. 발행/구독 모델로 알려져 있기도 하다.
&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4&quot;&gt;옵저버 패턴 - 위키백과&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들면, 안드로이드에서 Button이 클릭되었을 때 실행할 함수를 onclicklistener에 추가하는데 이와 같이 이벤트 핸들링 처리를 위해 사용되는 패턴이다. 이 패턴에는 Observable과 Observer가 등장한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Osbservable&lt;/strong&gt;: 등록된 Observer들을 관리하며, 새로운 데이터(이벤트)가 들어오면 등록된 Observer에게 데이터를 전달한다. 데이터를 생성해서 전달하기 때문에 Publisher(발행)라고 부른다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Observer&lt;/strong&gt;: Observable로 부터 데이터(이벤트)를 받을 수 있다. 데이터를 전달 받기 때문에 Subscriber(구독)라고 부른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 Observable은 데이터 흐름에 맞게 알림을 보내 Observer가 데이터를 사용할 수 있도록 한다. 즉, Observable을 이용해 데이터를 회수하고 변환하는 메커니즘을 정의하고, Observer은 이를 구독해 데이터가 준비되면 이에 반응한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_images/rxjava3-1.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서 처럼 Observer pattern은 다음의 순서로 동작한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Observable이 데이터 스트림을 처리하고, 완료되면 데이터를 발행(&lt;strong&gt;emit&lt;/strong&gt;)한다.&lt;/li&gt;
  &lt;li&gt;데이터를 발행할 때마다 구독(&lt;strong&gt;Subscribe&lt;/strong&gt;)하고 있는 모든 Observer가 알림을 받는다.&lt;/li&gt;
  &lt;li&gt;Observer는 수신한 데이터를 가지고 어떠한 일을 한다. (데이터를 소비(&lt;strong&gt;Consume&lt;/strong&gt;)한다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;데이터를 발행할 때 null은 발행할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;emit--subscribe&quot;&gt;Emit &amp;amp; Subscribe&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;observable의-데이터-발행-emit&quot;&gt;Observable의 데이터 발행 (Emit)&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;Observable이 데이터를 발행 한 후 보내는 알림에는 세 가지 종류가 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Emitter를 통해 알림을 보낸다고 생각하면 된다&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Emitter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onNext&lt;/code&gt; : 데이터의 발행을 알림&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onComplete&lt;/code&gt; : 모든 데이터의 발행이 완료되었음을 알림, 딱 한 번만 발생하며 이후에 onNext가 발생하면 안됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onError&lt;/code&gt; : 오류가 발생했음을 알림, 이후에 onNext와 onComplete가 발생하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;subscribe&quot;&gt;Subscribe&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;구독(Subscribe)이란 단순하게 수신한 데이터를 가지고 할 행동을 정의하는 것이다. Observer는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subsribe()&lt;/code&gt; 메소드에서 수신한 각각의 알림에 대해 실행할 내용을 지정한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Disposable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Disposable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Disposable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Disposable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Action&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Disposable class는 구독의 정상적인 해지를 돕는다.
onComplete 이벤트가 발생하면 dispose()를 호출해 Observable이 더 이상 데이터를 발행하지 않도록 구독을 해지한다.
또한 isDisposed()를 통해 구독이 해지되었는지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;observable-생성하기&quot;&gt;Observable 생성하기&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;이제 본격적으로 Observable을 사용해보자. RxJava에서는 &lt;strong&gt;연산자(Operator)&lt;/strong&gt; 를 통해 기존 데이터를 참조, 변형하여 Observable을 생성할 수 있다. Observable을 생성하는 함수를 &lt;strong&gt;팩토리 함수&lt;/strong&gt; 라고 하는데, 이 팩토리 함수는 다음 표처럼 구분할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;팩토리 함수&lt;/th&gt;
      &lt;th&gt;함수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;RxJava 1.x 기본 팩토리 함수&lt;/td&gt;
      &lt;td&gt;create(), just(), from()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RxJava 2.x 추가 팩토리 함수 (from() 함수 세분화)&lt;/td&gt;
      &lt;td&gt;fromArray(), fromIterable(), fromCallable(), fromFuture(), fromPublisher()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;기타 팩토리 함수&lt;/td&gt;
      &lt;td&gt;interval(), range(), timer(), defer() 등&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 중 일부를 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;just()&lt;/code&gt; 함수
  &lt;img src=&quot;/assets/img/post_images/rxjava3_just.png&quot; alt=&quot;just()&quot; /&gt;
  데이터를 발행하는 가장 쉬운 방법은 기존의 자료구조를 사용하는 것이다. just() 함수는 인자로 넣은 데이터를 차례로 발행하려고 Observable을 생성한다(실제 데이터의 발행은 subscribe() 함수를 호출해야 시작한다). 한 개의 값을 넣을 수도 있고 인자로 여러 개의 값(최대 10개)을 넣을 수도 있다. 단 타입은 모두 같아야 한다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nc&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PIGBEAN&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tech&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Blog&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PIGBEAN
  Tech
  Blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create()&lt;/code&gt; 함수
  &lt;img src=&quot;/assets/img/post_images/rxjava3_create.png&quot; alt=&quot;create()&quot; /&gt;
  just() 함수는 데이터를 인자로 넣으면 자동으로 알림 이벤트가 발생하지만 create() 함수는 onNext, onComplete, onError 같은 알림을 개발자가 직접 호출해야 한다. 그래서 create()는 라이브러리가 무언가를 해준다기보다 개발자가 무언가를 직접 하는 느낌이 강한 함수이다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Observable&amp;lt;String&amp;gt; source = Observable.create(emitter -&amp;gt; {
      emitter.onNext(&quot;PIGBEAN&quot;);
      emitter.onNext(&quot;Tech&quot;);
      emitter.onNext(&quot;Blog&quot;);
      emitter.onComplete();
  });
  source.subscribe(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PIGBEAN
  Tech
  Blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이처럼 실행 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;just()&lt;/code&gt;를 사용했을 때와 같지만 개발자가 직접 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onNext()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onComplete()&lt;/code&gt; 를 호출해야 한다는 것에서 차이가 있다. 앞서 설명했듯이 onComplete 이후에는 아이템에 더 발행되더라도 구독자는 데이터를 받지 못한다. 또한 오류가 발생했을 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onError()&lt;/code&gt;를 호출해서 에러 상황을 처리해야 한다.&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Observable&amp;lt;String&amp;gt; source = Observable.create(emitter -&amp;gt; {
      emitter.onNext(&quot;PIGBEAN&quot;);
      emitter.onError(new Throwable());
      emitter.onNext(&quot;Tech&quot;);
      emitter.onNext(&quot;Blog&quot;);
  });
  source.subscribe(System.out::println,
      throwable -&amp;gt; System.out.println(&quot;Good bye&quot;)
  );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PIGBEAN
  Good bye
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;Observable.create()를 사용할때는 주의해야 한다.&lt;/strong&gt;
  RxJava 문서에 따르면 create()는 RxJava에 익숙한 사용자만 활용하도록 권고한다. create()를 사용하지 않고 다른 팩토리 함수를 활용하면 같은 효과를 낼 수 있기 때문이다. 만약 그래도 사용해야 한다면 아래 사항을 확인해야 한다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Observable이 구독 해지(dispose)되었을때 등록된 콜백을 모두 해제해야 한다. 그렇지 않으면 잠재적으로 메모리 누수(memory leak)가 발생한다.&lt;/li&gt;
      &lt;li&gt;구독자가 구독하는 동안에만 onNext와 onComplete 이벤트를 호출해야 한다.&lt;/li&gt;
      &lt;li&gt;에러가 발생했을때는 오직 onError 이벤트로만 에러를 전달해야 한다.&lt;/li&gt;
      &lt;li&gt;배압(back pressure)을 직접 처리해야 한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;just()나 create()는 단일 데이터를 다룬다. 단일 데이터가 아닐때는 fromXXX() 계열 함수를 사용한다. &lt;strong&gt;배열, 리스트 등의 자료구조나 Future, Callable, Publisher 등은 from으로 시작하는 연산자를 통해 간단히 Observable로 변환할 수 있다.&lt;/strong&gt; 원래 RxJava 1.x에서는 from()과 fromCallable() 함수만 사용했었다. 그런데 from() 함수를 배열, 반복자, 비동기 계산 등에 모두 사용하다 보니 모호함이 있었다. 따라서 RxJava2에서는 from() 함수를 세분화했고 그중 하나가 아래 소개하는 fromArray() 함수이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_images/rxjava3_from.png&quot; alt=&quot;from&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fromArray()&lt;/code&gt; 함수&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fromArray()&lt;/code&gt; 함수를 통해 배열의 아이템을 Observable로 바꿔 아이템을 순차적으로 발행할 수 있다.&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  String[] itemArray = new String[]{&quot;PIGBEAN&quot;, &quot;Tech&quot;, &quot;Blog&quot;};
  Observable source = Observable.fromArray(itemArray);
  source.subscribe(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PIGBEAN
  Tech
  Blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fromCallable()&lt;/code&gt; 함수&lt;/p&gt;

    &lt;p&gt;RxJava는 비동기 프로그래밍을 하기 위한 라이브러리이다. 이전까지 기본적인 자료구조로 Observable을 생성하는 부분을 살펴봤다면 이번에는 기존 자바에서 제공하는 비동기 클래스나 인터페이스와의 연동을 살펴볼 차례이다. 먼저 살펴보는 것은 자바 5에서 추가된 동시성 API인 Callable 인터페이스이다. 비동기 실행 후 결과를 반환하는 call() 메서드를 정의한다.&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Callable&amp;lt;String&amp;gt; callable = () -&amp;gt; &quot;PIGBEAN tech blog&quot;;
  Observable source = Observable.fromCallable(callable);
  source.subscribe(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PIGBEAN Tech Blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;다양한-observable의-형태&quot;&gt;다양한 Observable의 형태&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Observable 스트림 이외에도 특별한 목적으로 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Single&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maybe&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Completable&lt;/code&gt; 등의 특별한 스트림이 있다. 이들은 Observable로 변환될 수 있고, 반대로 Observable도 이들 스트림으로 변환될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;single&quot;&gt;Single&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_images/rxjava3_single.png&quot; alt=&quot;Single&quot; /&gt;
Single은 단일 아이템만 발행한다. 이 특징 때문에 http 요청/응답 같은 이벤트 처리에 많이 쓰인다. Single을 사용해 http 이벤트에 실행 결과에 따른 &lt;strong&gt;응답 메시지&lt;/strong&gt; 를 전달받아 추후 프로그램에 활용할 수 있다. 데이터를 한 번만 발행하기 때문에 onNext(), onComplete() 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSuccess()&lt;/code&gt;를 사용해 데이터 발행이 완료됨을 알려준다. 오류처리는 Observable과 마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onError()&lt;/code&gt;을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Single.create(emitter -&amp;gt; emitter.onSuccess(&quot;Success&quot;))
    .subscribe(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Success
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&quot;completable&quot;&gt;Completable&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;Completable은 아이템을 발생하지 않고, 정상적으로 실행이 종료되었는 지에 대해 확인할 때 사용된다. http 이벤트를 처리할 때 응답 메시지를 받아보지 않고 그냥 http 이벤트가 잘 종료되었는 지만 확인하고 싶다면 Completable을 쓰면 된다. 아이템을 발행하지 않기 때문에 onNext()와 Single에서 쓰였던 onSuccess()는 쓰지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onComplete()&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onError()&lt;/code&gt;만을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Completable.create(emitter -&amp;gt; {
    System.out.println(&quot;OK&quot;)
    emitter.onComplete();
}).subscribe(() -&amp;gt; System.out.println(&quot;Completed&quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OK
Completed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&quot;maybe&quot;&gt;Maybe&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_images/rxjava3_maybe.png&quot; alt=&quot;Maybe&quot; /&gt;
Maybe는 Single과 Completable을 합쳐둔 느낌이다. Single처럼 아이템을 하나만 발행할 수도 있고, Completable처럼 발행하지 않을 수도 있다. 따라서 아이템을 발행했을 때에는 onSuccess()를 호출하고, 발행하지 않을 때에는 onComplete()를 호출한다. onSuccess() 이후에 다시 onComplete()를 호출할 필요는 없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;참고-내용-출처-&quot;&gt;참고 내용 출처 :&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.yena.io/studynote/&quot;&gt;https://blog.yena.io/studynote/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://12bme.tistory.com/570&quot;&gt;https://12bme.tistory.com/570&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;스다 토모유키, 『RxJava 리액티브 프로그래밍』, 이승룔, (주)도서출판 길벗(2019)&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Beanie</name>
        
        
      </author>

      

      
        <category term="RxJava" />
      

      
        <summary type="html">Observable 이란</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">RxJava(2) - Reactive Streams</title>
      <link href="http://localhost:4000/RxJava(2)-Reactive-Streams" rel="alternate" type="text/html" title="RxJava(2) - Reactive Streams" />
      <published>2022-01-10T23:42:00+09:00</published>
      <updated>2022-01-10T23:42:00+09:00</updated>
      <id>http://localhost:4000/RxJava(2)%20-%20Reactive%20Streams</id>
      <content type="html" xml:base="http://localhost:4000/RxJava(2)-Reactive-Streams">&lt;p&gt;앞선 글에서 RxJava가 Reactive Streams 사양을 구현한다고 하였다. 따라서 Reactive Streams이 뭔지 자세히 알면 RxJava를 더 쉽게 이해할 수 있다. 그래서 이번 글에서는 Reactive Streams을 더 알아보았다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;reactive-streams란&quot;&gt;Reactive Streams란&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;라이브러리나 프레임워크에 상관없이 데이터 스트림을 비동기로 다룰 수 있는 공통 메커니즘으로, 이 메커니즘을 편리하게 사용할 수 있는 인터페이스를 제공한다. 즉, Reactive Streams는 인터페이스만 제공하고 구현은 각 라이브러리와 프레임워크에서 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reactive Streams: &lt;a href=&quot;https://www.reactive-streams.org/&quot;&gt;https://www.reactive-streams.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The purpose of Reactive Streams is to provide a standard for asynchronous stream processing with non-blocking backpressure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Reactive Stream 스펙 제일 위에 나오는 문구이다. Reactive Stream의 목적이 명확하게 나와있다. 해석해보면 &lt;strong&gt;“Reactie Stream의 목적은 non-blocking backpressure를 이용하여 비동기 스트림 처리의 표준을 제공하는 것이다.”&lt;/strong&gt; 라고 되어 있다.&lt;/p&gt;

&lt;p&gt;java의 RxJava, Spring5 Webflux의 Core에 있는 ProjectReactor 프로젝트 모두 reactive Stream을 사용하고 있다. 또한 Java9에 추가된 Flow 역시 reactvie stream 스펙을 채택하여 쓰고 있다. 따라서 비동기 프로젝트를 잘 이해하기 위해서는 기본 스펙이 되는 Reactive Stream에 대해서 이해가 필요하다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&quot;reactive-stream의-목적&quot;&gt;Reactive Stream의 목적&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;계속적으로 들어오는 스트림 데이터를 효율적으로 처리하기 위해서는 비동기 시스템이 효과적이다. &lt;strong&gt;비동기 처리를 하면서 가장 중요한 문제는 데이터를 받는 곳에서 데이터를 예측 가능한 범위 내에서 신중하게 제어할 수 있도록 해야한다는 것&lt;/strong&gt; 이다. Publisher는 Subscriber의 상태에 상관없이 데이터를 전달하는데만 집중하기 때문에 보내는 속도와 처리 속도가 다를 수 있다.&lt;/p&gt;

&lt;p&gt;예를들어 데이터를 주는 곳에서 빠르게 데이터를 생성하여 1초에 50개의 데이터를 보내는데 데이터를 받는 곳의 수용 능력으로는 1초에 10개 정도 밖에 데이터를 처리하지 못한다면 다음과 같이 문제가 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Subscriber에 별도의 queue(버퍼)를 두고 처리하지 않고 대기중인 데이터를 저장할 수 있다.&lt;/li&gt;
  &lt;li&gt;하지만, queue의 사용 가능한 공간도 전부 금방 소모될 것이다.&lt;/li&gt;
  &lt;li&gt;queue의 크기를 넘어가게 되면 데이터는 소실될 것이다.&lt;/li&gt;
  &lt;li&gt;queue의 크기를 너무 크게 생성하면 OOM(Out Of Memory) 문제가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서, &lt;strong&gt;Reactive Stream의 주된 목적은 비동기의 경계를 명확히하여 스트림 데이터의 교환을 효과적으로 관리하는 것&lt;/strong&gt;에 있다. BackPressure가 이를 달성할 수 있게 해주는 주요한 부분이다.&lt;/p&gt;

&lt;p&gt;다시 말해 Reactive Stream은 다음의 스트림 지향 라이브러리에 대한 표준 및 사양이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;잠재적으로 무한한 숫자의 데이터 처리&lt;/li&gt;
  &lt;li&gt;순서대로 처리&lt;/li&gt;
  &lt;li&gt;컴포넌트간에 데이터를 비동기적으로 전달&lt;/li&gt;
  &lt;li&gt;backpressure를 이용한 데이터 흐름제어&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&quot;backpressure-배압&quot;&gt;BackPressure (배압)&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;앞서 Reactive Stream의 목적이 backpressure을 이용하고 비동기 스트림의 표준을 제공하는 것이라고 언급했다. BackPressure을 더 자세히 살펴보자. 배압은 한마디로 데이터 통지량을 제어하는 기능을 말한다. &lt;a href=&quot;https://www.reactivemanifesto.org/ko/glossary&quot;&gt;리액티브 선언문 용어집&lt;/a&gt; 에서는 BackPressure을 다음과 같이 설명하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 컴포넌트가 부하를 이겨내기 힘들 때, 시스템 전체가 합리적인 방법으로 대응해야 한다. 과부하 상태의 컴포넌트에서 치명적인 장애가 발생하거나 제어 없이 메시지를 유실해서는 안 된다. 컴포넌트가 대처할 수 없고 장애가 발생해선 안 되기 때문에 컴포넌트는 상류 컴포넌트들에 자신이 과부하 상태라는 것을 알려 부하를 줄이도록 해야 한다. 이러한 배압은 시스템이 부하로 인해 무너지지 않고 정상적으로 응답할 수 있게 하는 중요한 피드백 방법이다. 배압은 사용자에게까지 전달되어 응답성이 떨어질 수 있지만, 이 메커니즘은 부하에 대한 시스템의 복원력을 보장하고 시스템 자체가 부하를 분산할 다른 자원을 제공할 수 있는지 정보를 제공할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞서 데이터를 보내는 속도와 처리 속도가 다르면 문제가 된다고 했다. BackPressure로 이 문제를 어떻게 해결할 수 있을까?&lt;/p&gt;

&lt;p&gt;보내는 쪽과 받는 쪽의 속도가 다른 문제는 &lt;strong&gt;Publisher가 Subscriber에게 데이터를 Push 하던 기존의 방식을 Subscriber가 Publisher에게 자신이 처리할 수 있는 만큼의 데이터를 Request하는 방식으로 해결할 수 있다.&lt;/strong&gt; 필요한(처리할 수 있는) 만큼만 요청해서 Pull하는 것이다. 데이터 요청의 크기가 Subscriber에 의해서 결정되는 것이다. 이를 dynamic pull 방식이라 부르며, Back Pressure의 기본 원리이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;reactive-streams의-구성&quot;&gt;Reactive Streams의 구성&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Reactive Stream은 데이터를 만들어 통지하는 &lt;strong&gt;Publisher(생산자)&lt;/strong&gt; 와 통지된 데이터를 받아 처리하는 &lt;strong&gt;Subscriber(소비자)&lt;/strong&gt; 로 구성된다. Subscriber가 Publisher를 &lt;strong&gt;구독(subscribe)&lt;/strong&gt; 하면 Publisher가 통지한 데이터를 Subscriber가 받을 수 있다.&lt;/p&gt;

&lt;p&gt;아래는 Reactive Streams API이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Subscription&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Subscription&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Publisher&lt;/strong&gt; : 데이터를 통지하는 생산자
    &lt;ul&gt;
      &lt;li&gt;Subscriber를 받아들이는 subscribe 메서드 하나만 갖는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; : 데이터를 받아 처리하는 소비자
    &lt;ul&gt;
      &lt;li&gt;Subscription을 등록하고 Subscription에서 오는 신호에 따라서 동작한다.&lt;/li&gt;
      &lt;li&gt;데이터를 받아 처리할 수 있는 onNext, 에러를 처리하는 onError, 모든 데이터를 받아 완료되었을 때는 onComplete, 그리고 Publisher로부터 Subscription을 전달 받는 onSubscribe 메서드로 이루어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Subscription&lt;/strong&gt; : Publisher와 Subscriber 사이에서 중계하는 역할
    &lt;ul&gt;
      &lt;li&gt;데이터 개수를 요청하고 구독을 해지하는 인터페잏스&lt;/li&gt;
      &lt;li&gt;n개의 데이터를 요청하는 request와 구독을 취소하는 cancel을 갖는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 
이를 토대로 다음과 같은 flow를 만들 수 있다.
  &lt;img src=&quot;/assets/img/post_images/rxjava2-1.png&quot; alt=&quot;Reactive streams flow&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Publisher에서 사용할 Subscription을 구현한다.&lt;/li&gt;
  &lt;li&gt;Publisher에서 전달(publishing)할 data를 만든다.&lt;/li&gt;
  &lt;li&gt;Publisher는 subscribe() 메서드를 통해 subscriber를 등록한다.&lt;/li&gt;
  &lt;li&gt;Subscriber는 onSubscribe() 메서드를 통해 Subscription을 등록하고 Publisher를 구독하기 시작한다. 이는 Publisher에 구현된 Subscription을 통해 이루어진다. 이렇게 하면 Publisher와 Subscriber는 Subscription을 통해 연결된 상태가 된다. onSubscribe() 내부에 Subscription의 request()를 요청하면 그때부터 data 구독이 시작된다.&lt;/li&gt;
  &lt;li&gt;Suscriber는 Subscription 메서드의 request() 또는 cancel()을 호출을 통해 data의 흐름을 제어할 수 있다.&lt;/li&gt;
  &lt;li&gt;Subscription의 request()에는 조건에 따라 Subscriber의 onNext(), onComplete() 또는 onError()를 호출합니다. 그러면 Subscriber의 해당 메서드의 로직에 따라 request() 또는 cancle()로 제어하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;참고-내용-출처-&quot;&gt;참고 내용 출처 :&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jongmin92.github.io/2019/11/05/Java/reactive-1/&quot;&gt;https://jongmin92.github.io/2019/11/05/Java/reactive-1/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sabarada.tistory.com/98&quot;&gt;https://sabarada.tistory.com/98&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;스다 토모유키, 『RxJava 리액티브 프로그래밍』, 이승룔, (주)도서출판 길벗(2019)&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Beanie</name>
        
        
      </author>

      

      
        <category term="RxJava" />
      

      
        <summary type="html">앞선 글에서 RxJava가 Reactive Streams 사양을 구현한다고 하였다. 따라서 Reactive Streams이 뭔지 자세히 알면 RxJava를 더 쉽게 이해할 수 있다. 그래서 이번 글에서는 Reactive Streams을 더 알아보았다.   Reactive Streams란</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">RxJava(1) - 개요</title>
      <link href="http://localhost:4000/RxJava(1)-%EA%B0%9C%EC%9A%94" rel="alternate" type="text/html" title="RxJava(1) - 개요" />
      <published>2022-01-10T21:55:00+09:00</published>
      <updated>2022-01-10T21:55:00+09:00</updated>
      <id>http://localhost:4000/RxJava(1)%20-%20%EA%B0%9C%EC%9A%94</id>
      <content type="html" xml:base="http://localhost:4000/RxJava(1)-%EA%B0%9C%EC%9A%94">&lt;p&gt;Catty 서비스를 개발하면서 그동안 미뤄뒀던 RxJava에 대한 공부와 함께 서비스에 코드를 적용해보았다.&lt;/p&gt;

&lt;p&gt;Catty 서비스의 경우 서비스를 통해서 촬영한 스크린샷과 사진을 구글 드라브에 바로 연동을 하도록 되어 있다. 이 때 구글 드라이브에 ‘Catty’라는 루트 폴더를 생성하고, 그 루트 폴더 내에 각각 스크린샷, 사진 저장용 폴더를 생성한 후 그 속에 사진을 저장하도록 구조가 잡혀있었다.&lt;/p&gt;

&lt;p&gt;만약 구글드라이브 내에 한 번이라도 스크린샷, 사진 용 폴더가 생성이 되었다면 폴더 아이디를 통해 추가 폴더 생성 과정없이 바로 자료를 저장하지만, 미리 생성되어 있던 폴더가 없거나 저장과정에서 어떤 오류가 발생하면 루트 폴더 생성 → 스크린샷/사진 폴더 생성 → 자료 저장의 과정을 밟아야 했고 이 과정에서 콜백이 증가하면서 콜백 복잡도가 증가(callback hell)하게 되었다.&lt;/p&gt;

&lt;p&gt;그래서 우선적으로 RxJava를 이용하여 이런 부분을 리팩토링 하고 점차 다른 부분도 RxJava를 적용해 나가보았다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;rxjava란&quot;&gt;RxJava란&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;RxJava는 자바(Java)에서 리액티브 프로그래밍을 구현하는 데 사용하는 라이브러리이다. 이벤트 처리와 같은 비동기 처리에 최적화되었으며, 2.0 버전부터 Reactive Streams 사양을 구현한다.&lt;/p&gt;

&lt;p&gt;RxJava는 넷플릭스(Netflix)의 기술블로그에서 처음 소개되었다. &lt;strong&gt;그 당시 넷플릭스는 REST 기반의 서비스 API 호출 횟수와 서비스의 전반적인 성능을 개선하는 프로젝트를 진행했고, 그결과 .NET 환경의 리액티브 확장 라이브러리(Rx)를 JVM에 포팅하여 RxJava를 만들었다.&lt;/strong&gt; 넷플릭스에서 RxJava를 만들게된 핵심적인 이유를 다음과 같이 밝혔다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동시성을 적극적으로 끌어안을 필요가 있다(Embrace Concurrency)&lt;/p&gt;

    &lt;p&gt;첫번째 이유의 원인은 자바가 동시성 처리를 하는데 번거로움이 있기 때문이다. 이를 해결하려고 넷플릭스는 클라이언트의 요청을 처리하는 서비스 계층(service layer)에서 동시성을 적극적으로 끌어안았다. &lt;strong&gt;클라이언트의 요청을 처리할때 다수의 비동기 실행 흐름(스레드 등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자바 Future를 조합하기 어렵다는 점을 해결해야 한다(Java Futures are Expensive to Compose)&lt;/p&gt;

    &lt;p&gt;두번째 이유의 원인은 2013년 당시 자바8에서 제공하는 CompletableFuture 같은 클래스가 제공되지 않았기 때문이다. 그래서 비동기 흐름을 조합할 방법이 거의없었다. &lt;strong&gt;RxJava에서는 이를 해결하려고 비동기 흐름을 조합(compose)할 수 있는 방법을 제공한다. RxJava에서는 조합하는 실행 단위를 리액티브 연산자(Operators)라고 한다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;콜백 방식의 문제점을 개선해야 한다(Callbacks Have Their Own Problems)&lt;/p&gt;

    &lt;p&gt;세번째 이유의 원인은 콜백이 콜백을 부르는 콜백 지옥(Callback Hell) 상황이 코드의 가독성을 떨어뜨리고 문제 발생시 디버깅을 어렵게 만들기 때문이다. &lt;strong&gt;비동기 방식으로 동작하는 가장 대표적인 프로그래밍 패턴은 콜백이다. 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했다.&lt;/strong&gt; 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리액티브 프로그래밍은 비동기 연산을 필터링, 변환, 조합해 위 세가지 핵심이유를 해결할 수 있다. 따라서 RxJava는 Observable과 같은 데이터 소스와 map(), filter(), reduce()와 같은 리액티브 연산자를 제공한다.&lt;/p&gt;

&lt;p&gt;RxJava는 2016년 10월에 완전히 새로 작성한 RxJava 2.0을 발표했다. RxJava 2.0은 RxJava 1.x를 Reactive-Streams 스펙 기반으로 새롭게 개선한 것이므로 공통점도 많고 차이점도 많다.&lt;/p&gt;

&lt;p&gt;Reactive-Stream 스펙은 자바8에 도입된 Stream API와 Observable 기반의 리액티브 프로그래밍을 포괄하는 표준 스펙으로 자바 9에 도입되었다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;리액티브-프로그래밍이란&quot;&gt;리액티브 프로그래밍이란&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;앞서 RxJava는 자바에서 리액티브 프로그래밍을 구현하는 데 사용하는 라이브러리라고 하였다. 그런데 리액티브 프로그래밍이 정확히 뭘까?
정의상으로 리액티브 프로그래밍은 &lt;strong&gt;변화의 전파&lt;/strong&gt;와 &lt;strong&gt;데이터 흐름&lt;/strong&gt;과 관련된 &lt;strong&gt;선언적 프로그래밍&lt;/strong&gt; 패러다임이다.&lt;/p&gt;

&lt;p&gt;각각을 조금 뜯어 살펴보면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;변화의 전파와 데이터 흐름&lt;/strong&gt; : 데이터가 변경 될 때 마다 이벤트를 발생시켜서 데이터를 계속적으로 전달한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;선언적 프로그래밍&lt;/strong&gt; : 실행할 동작을 구체적으로 명시하는 명령형 프로그램이과 달리 선언형 프로그래밍은 단순히 목표를 선언한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어, GPS 위치 정보가 변경될 때의 데이터 전송 흐름을 상상해보자. 이동해서 위치 정보가 변경될 때마다 데이터를 전송하고 이동을 멈추면 데이터 전송도 중지하는 것처럼 생성되는 데이터를 한 번에 보내지 않고 각각의 데이터가 생성될 때마다 순서대로 보낸다. 이런 데이터 흐름을 데이터 스트림(data stream)이라고 한다. 이 것은 이미 생성된 데이터 집합인 리스트(list) 같은 컬렉션(collection)과는 다르게 앞으로 발생할 가능성이 있는 데이터까지도 포함하는 데이터 집합체이다.&lt;/p&gt;

&lt;p&gt;좀 더 쉽게 이해하기 위해 명령형 프로그래밍과 비교해보자.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h3 id=&quot;명령형-프로그래밍-vs-리액티브-프로그래밍&quot;&gt;명령형 프로그래밍 vs 리액티브 프로그래밍&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;명령형 프로그래밍 방식은 변경이 발생했는 지 질문해서 응답에 따라 데이터를 가져오는 pull 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(push) 방식이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Push 방식(리액티브 프로그래밍)&lt;/strong&gt; : 데이터의 변화가 발생했을 때 변경이 발생한 곳에서 데이터를 보내주는 방식
    &lt;ul&gt;
      &lt;li&gt;RTC(Real Time Communication)&lt;/li&gt;
      &lt;li&gt;소켓 프로그래밍&lt;/li&gt;
      &lt;li&gt;DB Trigger&lt;/li&gt;
      &lt;li&gt;Spring의 ApplicationEvent&lt;/li&gt;
      &lt;li&gt;Angular의 데이터 바인딩&lt;/li&gt;
      &lt;li&gt;스마트폰의 Push 메시지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pull 방식&lt;/strong&gt; : 변경된 데이터가 있는지 요청을 보내 질의하고 변경된 데이터를 가져오는 방식
    &lt;ul&gt;
      &lt;li&gt;클라이언트 요청 &amp;amp; 서버 응답 방식의 애플리케이션&lt;/li&gt;
      &lt;li&gt;Java와 같은 절차형 프로그래밍 언어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;리액티브-프로그래밍-장점&quot;&gt;리액티브 프로그래밍 장점&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;리액티브 프로그래밍을 이용하면 비동기처리를 쉽게 구현할 수 있다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;리액티브 프로그래밍에서 데이터를 생산하는 측은 데이터를 전달하는 것까지만 책임진다. 그러므로 데이터를 생산하는 측은 데이터를 소비하는 측이 전달받은 데이터로 무엇을 하는 지는 몰라도 된다. 또한, 데이터를 생산하는 측은 데이터를 소비하는 측에서 무엇을 하든지 관계가 없으므로 소비하는 측의 처리를 기다릴 필요가 없다. 그러므로 데이터를 통지한 후 데이터를 소비하는 측에서 데이터를 처리하는 도중이라도 데이터를 생산하는 측은 바로 다음 데이터를 처리할 수 있다. 이처럼 비동기 처리를 쉽게 구현 가능하다.
&lt;br /&gt;
 
&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;리액티브-프로그래밍을-위해-알아야-될-것들&quot;&gt;리액티브 프로그래밍을 위해 알아야 될 것들&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;리액티브 프로그래밍을 더 잘 이해하기 위해 알아두면 좋은 내용들을 정리해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Observable : 데이터 소스 (변경되는 데이터 관찰)&lt;/li&gt;
  &lt;li&gt;리액티브 연산자(Operators) : 데이터 소스를 처리하는 함수&lt;/li&gt;
  &lt;li&gt;스케쥴러(Scheduler) : 스레드 관리자&lt;/li&gt;
  &lt;li&gt;Subscriber : Observable이 발행하는 데이터를 구독하는 구독자&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍 : RxJava에서 제공하는 연산자(Operator) 함수를 사용&lt;/li&gt;
  &lt;li&gt;doOnNext : 데이터가 발생한 후 onNext 함수가 호출된 후 호출되는 메소드&lt;/li&gt;
  &lt;li&gt;subscribeOn : 데이터가 발행, 데이터의 흐름을 결정짓는 스레드를 결정&lt;/li&gt;
  &lt;li&gt;observeOn : 발행된 데이터를 가공하고 구독해서 처리하는 스레드를 결정&lt;/li&gt;
  &lt;li&gt;리액티브 기본 동작 흐름 : 데이터 발행 -&amp;gt; 데이터 가공 -&amp;gt; 데이터 구독 -&amp;gt; 결과 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;rxjava의-특징&quot;&gt;RxJava의 특징&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;다시 RxJava로 돌아와 RxJava의 특징을 살펴보면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디자인 패턴인 옵저버(Observer)패턴을 잘 확장함
    &lt;ul&gt;
      &lt;li&gt;옵저버 패턴은 &lt;a href=&quot;https://beanie00.github.io/posts/RxJava(3)-Observable/&quot;&gt;&lt;strong&gt;RxJava(3) - Observable&lt;/strong&gt;&lt;/a&gt;에서 자세히 다루었다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉬운 비동기 처리&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍의 영향을 받아 함수형 인터페이스를 인자로 전달받는 메서드를 사용해 대부분의 처리를 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;
&lt;h2 id=&quot;rxjava를-어떻게-공부하면-좋을까&quot;&gt;RxJava를 어떻게 공부하면 좋을까&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;rxjava-공부가-어려운-이유&quot;&gt;RxJava 공부가 어려운 이유&lt;/h3&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;자바는 thread 기반의 프로그래밍인데 반해 RxJava는 비동기 프로그래밍을 위한 라이브러리라서 개념과 접근 방식이 다르다.
    &lt;ul&gt;
      &lt;li&gt;전통적인 스레드 기반의 프로그래밍은 다수의 스레드를 활용하는 경우 예상치 못한 문제가 발생하고 디버깅하기도 어려웠다. 특히 문제를 재현하기 어렵거나 미묘한 경우도 상당수 발생한다. 이러한 문제를 해결하기 위해 RxJava는 함수형 프로그래밍 기법을 도입했다. 함수형 프로그래밍은 부수 효과가 없는 순수 함수를 지향하므로 스레드에 안전하다.&lt;/li&gt;
      &lt;li&gt;자바는 함수형 언어가 아니므로 RxJava 라이브러리는 순수 함수로 작성된 &lt;strong&gt;리액티브 연산자&lt;/strong&gt; 를 제공한다. 이 리액티브 연산자 덕분에 RxJava는 리액티브 프로그래밍이 되는 것이다. 리액티브 연산자를 활용하면 목적을 달성할 수 있는 도구인 ‘함수형 프로그래밍’ 방식으로 ‘스레드에 안전한 비동기 프로그램’을 작성할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 함수형 연산자를 어떻게 활용해야할 지 몰라 RxJava를 이용한 코딩에 어려움을 느낄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 다음의 순서로 RxJava를 학습하는 것을 추천한다.
&lt;br /&gt;
 &lt;/p&gt;
&lt;h3 id=&quot;rxjava-추천-학습-순서&quot;&gt;RxJava 추천 학습 순서&lt;/h3&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;Observable 클래스를 명확하게 이해&lt;/li&gt;
  &lt;li&gt;map(), filter(), reduce(), flatMap() 등의 함수의 사용법 익히기&lt;/li&gt;
  &lt;li&gt;생성 연산자, 결합 연산자, 변환 연산자 등 카테고리별 주요 함수를 공부&lt;/li&gt;
  &lt;li&gt;스케줄러의 의미를 배우고 subscribeOn()과 observeOn() 함수의 차이 알기&lt;/li&gt;
  &lt;li&gt;그밖의 디버깅, 흐름 제어 함수를 익히기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;참고-내용-출처-&quot;&gt;참고 내용 출처 :&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;인프런 - Kevin의 알기 쉬운 RxJava 1부&lt;/li&gt;
  &lt;li&gt;RxJava 리액티브 프로그래밍&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://12bme.tistory.com/570&quot;&gt;https://12bme.tistory.com/570&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Beanie</name>
        
        
      </author>

      

      
        <category term="RxJava" />
      

      
        <summary type="html">Catty 서비스를 개발하면서 그동안 미뤄뒀던 RxJava에 대한 공부와 함께 서비스에 코드를 적용해보았다.</summary>
      

      
      
    </entry>
  
</feed>
