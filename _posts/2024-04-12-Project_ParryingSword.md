---
title: Project- Parrying Sword
date: 2024-04-12 16:50:00 +/-0900
categories: [Project, Unity]
tags: [project, unity, rogue-lite, hunting action] # TAG names should always be lowercase
---

![icon](assets/img/parringsword/ParryingSowrdIcon.png)
[깃허브 링크](https://github.com/Lagooneng/ParryingSword)
<br>
[개발일지 링크](https://lagooneng.tistory.com/category/%EC%9C%A0%EB%8B%88%ED%8B%B0%20%EA%B2%8C%EC%9E%84%20%EA%B0%9C%EB%B0%9C/%EB%A9%94%EC%9D%B8%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%3A%20%20Parrying%20Sowrd)

## 프로젝트 설명

<br>

Parrying Sword는 Unity Engine으로 만들어진 로그라이트 헌팅액션 장르의 게임입니다.<br>
로그라이트, 헌팅액션 두 가지 장르의 관점으로 살펴볼 수 있습니다

- ### 로그라이트

![stageUML](assets/img/parringsword/stageUML.png)
로그라이트란, 매번 달라지는 요소들(특히 스테이지)이 존재하고,<br>
해당 요소들을 생성하는 규칙이 있으며 플레이어는 이러한 요소들을 이용하고 극복해 나가는 장르입니다.<br>
위의 이미지는 스테이지를 생성하는 클래스 다이어그램입니다.<br>
<br>
우선 맵의 조각이 있고, 각각의 조각은 왼쪽이 뚫려있거나(L타입), 왼쪽과 오른쪽이 뚫려있는(LR타입) 등<br>
어떤 방향이 뚫려 있는지에 따라 타입을 부여받습니다. 그리고 뚫려있는 방향이 옆 맵과 이어지면(ex. L타입-R타입) 해당 맵들은 자연스럽게 연결됩니다.<br>
<br>
그리고 일단 스타트 지점과 엔드 지점이 있으면, 양 쪽 지점을 이을 수 있는 Main Road를 만들어줍니다.<br>
각각의 맵 조각이 이어지도록 생성하는 규칙이 있습니다.<br>
스타트 지점과 엔드 지점을 이을 수 있는 길을 만들고, 나머지 지형은 이전 지형에 따라 어느정도 가중치를 두어 자연스럽게 생성되도록 하였습니다.<br>
<br>
각각의 맵 조각의 실제 구현은 유니티에서 지원하는 프리팹 기능을 이용해 만들어야 합니다.<br>
각각의 조각들을 타입에 맞게 여러개 미리 만들어놓고 등록하면 타입에 맞는 조각들 중 하나가 뽑아져서 다양한 맵이 만들어질 것입니다.<br>
<br>
이러한 시스템은 로그라이트 장르의 Spelunky 시리즈에서 비슷한 맵의 구조가 간혹 나오는 것을 보고 맵의 구조를 예측하는 사람들이 있는 것을 보고,<br>
이런 식으로 구현하지 않았을까 생각이 들어 설계하게 되었습니다.
<br>

![map1](assets/img/parringsword/map1.png)
이처럼 시작하기 전에는 맵이 존재하지 않지만,
<br><br>

![map2](assets/img/parringsword/map2.png)
게임이 시작하면 규칙에 따라 맵이 생성됩니다.<br>
그리고 각 맵의 조각에는 소형 몬스터가 설정되어 있는 경우도 있는데,<br>
몬스터들을 피하거나 쓰러뜨려서 피해를 최소화시키며 각 스테이지를 통과하고 보스 스테이지에 도달하게 됩니다.<br>
이러한 과정을 위해 와이어액션이나 벽타기 등의 액션을 만들어두었습니다.<br>

<hr>

- ### 헌팅 액션

![hunting1](assets/img/parringsword/hunting1.png)

헌팅 액션이란 거대한 몬스터를 '사냥'하는 장르입니다.<br>
몬스터와 직접적으로 전투하는 것이 메인인 만큼, 몬스터의 패턴에 공을 들였습니다.<br>
다른 게임들과 차별화 할만한 점은, 프로젝트 이름처럼 Parrying, 공격을 받아치는 것입니다.<br>
적의 공격을 타이밍을 잘 맞춰서 받아칠 수가 있습니다.<br>
<br>
받아치는 것에 성공하면 이펙트가 나오며 큰 대미지를 주고, 더 강한 공격으로 연계가 가능해집니다.<br>
그렇다고 패링 공격만 있는 것은 아니며, 기본 공격이 2개 존재하는데 베기 -> 찌르기 연계가 가능합니다.<br>
<br>
또한, 패링 후 연계되는 강한 공격은 딜레이가 커서 위험하고, 패링 자체도 딜레이를 크게 설정해 두었기에 적의 연계 공격에 취약합니다.<br>
그래서 패링 성공 이후에는 딜레이가 적은 찌르기로 연계가 가능합니다. 연계를 통해 상대 몬스터의 공격을 파훼해야 합니다.<br>
<br>

![hunting2](assets/img/parringsword/hunting2.png)

<br>
물론 대형 몬스터 말고도, 일반 스테이지 진행 시 등장하는 소형 몬스터에 대처하는 것 또한 중요합니다.<br>
체력 회복의 수단은 한정적이고, 몬스터들의 공격 방식은 몬스터마다 다르기에 플레이어는 도망칠지, 패링할지, 일반 공격을 할지 고려해야 합니다.<br>
<br>
위 이미지의 경우 플레이어와의 벡터를 계산해 불을 날리는 몬스터입니다. 이 밖에도 다양한 행동 원리를 몬스터들이 있습니다.<br>
<br>
이 프로젝트 구상의 계기와 같은 요소입니다.<br>
몬스터헌터 시리즈를 하는데 굉장히 재밌어서 헌팅 액션 장르로 만들고 싶었습니다.<br>
여기에 로그라이트 장르까지 더해서 기본 게임의 틀이 잡혔습니다.<br>

<hr>

## 액션의 모티브

![animationState](assets/img/parringsword/animationState.png)
예전에 유튜브에서 독일의 리히테나워라는 사람이 만든 롱소드 검술 영상이 있어 본적이 있습니다.<br>
옥스, 폼 탁, 플루크, 알버 네 가지 자세를 가지고 자세들을 변형하는 과정이 곧 공격, 방어라는 체계입니다.<br>
<br>
여기서 모티브를 얻어 캐릭터 애니메이션 일러스트는 저 네가지 자세와 추가적으로 필요한 자세(랑엔오트, 벡셀)을 만들고<br>
유니티의 애니메이션 기능으로 자세들을 조합하여 베기(hauen), 찌르기(stechen) 등의 공격과 패링을 구현하였습니다.<br>
<br>
그 밖의 와이어액션이나 점프, 힐 등의 액션을 추가하여 완성되었습니다.

<hr>

## 프로젝트 진행 중 있었던 이슈, 추가 설명

1. ### 로그라이트 시스템 구성

<br>
Main Road를 만드는 방식 구현에 조금 고민이 있었고,<br>
처음엔 맵에 가중치가 존재하지 않아 맵이 나와도 부자연스러웠습니다.<br>
![map3](assets/img/parringsword/map3.png)
![map4](assets/img/parringsword/map4.png)
<br>
Main Road를 만드는 건 단순히 최단, 최장 거리가 나와서는 안되며 난수에 의한 처리가 필요했고,<br>
그 난수에 의한 처리에 더해 입구와 출구가 연결되도록 추가 조건이 필요했습니다.<br>
실제 구현을 하면서는 조금 달라진 부분이 있기는 한데, 위의 구현법을 기반으로 맵이 만들어집니다.<br>
<br>
![map5](assets/img/parringsword/map5.png)
<br>
맵이 부자연스러운 문제는 맵마다 가중치를 두고, 거기에 이전 타입이 무엇이냐에 따라 추가로 가중치를 부여하였습니다.<br>
값을 조절해가며 적절한 값을 설정해두었습니다.<br>

1. ### 와이어 액션 구현

   ![wireAction1](assets/img/parringsword/wireAction1.png)
   <br>
   맵이 복잡해서 점프, 벽타기만으로는 플레이가 답답해지는 느낌이 강하여 추가한 액션입니다.<br>
   가까이에 캐치 가능한 벽이 있으면 해당 벽을 집게로 잡고, 와이어로 몸을 끌어당기는 것처럼 보이게 만들었습니다.<br>
   <br>
   문제는 와이어액션이 현실적인 움직임은 아니기에 vector와 velocity를 계속해서 조절해줄 필요가 있었습니다.<br>
   예를 들어, 와이어를 타다가 중간에 끊거나, 벽과 너무 가까워서 플레이어가 끊지 않아도 강제로 끊어야 하는 등,<br>
   고려해야 하는 변수가 많았습니다. 이를 해결하기 위해 발생 가능한 상황을 계속 테스트하며 코드를 수정하였습니다.<br>
   <br>

2. ### 물 구현과 최적화 문제

   ![water](assets/img/parringsword/water.png)
   <br>
   [당시의 개발 일지](https://lagooneng.tistory.com/40)
   <br>
   현재 아직 물이 사용되는 스테이지가 구현되지 않았으나, 물은 구현이 되어있습니다.<br>
   바다 스테이지가 될 예정이라, 맵 전체를 덮을 정도의 물이 필요합니다.<br>
   <br>
   물은 플레이어가 뛰어들거나 나가면 수면이 일렁이는 효과가 필요합니다.<br>
   물결을 플레이어의 위치를 기반으로 sin 함수 계산하고 Sprite Shape Controller로 조정하여 구현하였는데,<br>
   문제는 최적화였습니다. 하나의 거대한 물 오브젝트를 두면 일렁임이 발생하면 엄청난 프레임 드랍이 발생합니다.<br>
   <br>
   물을 여러개로 분산시켜서 해결했습니다. 일렁임이 염향을 끼칠 수 있는 범위가 분산된 만큼 제한되어 최적화에 도움이 되었습니다.<br>
   <br>

3. ### 상호작용과 메뉴 구현

   <br>
   ![menu](assets/img/parringsword/menu.png)
   [당시의 개발 일지2](https://lagooneng.tistory.com/61)
   <br>
   어떠한 물체와의 상호작용과 메뉴의 구현입니다.<br>
   정확히 말하면, 메뉴 자체도 어떠한 물체와 상호작용을 한다는 개념으로 만들었습니다.<br>
   <br>
   상호작용이 가능한 물체와 접촉하면(컬라이더) 플레이어가 상호작용하는 오브젝트에 등록이 됩니다.<br>
   그리고 각각의 입력은 스트라티지 패턴으로 정의되어 각 오브젝트는 자신이 등록된 경우 자신의 행동을 전달해줍니다.<br>
   플레이어는 그 내용은 모르지만 일단 버튼을 누르면 해당하는 오브젝트의 액션이 발생하게 됩니다.<br>
   <br>
   메뉴의 경우 esc를 누르면 상호작용 오브젝트 자리에 메뉴 오브젝트를 넣어줍니다.<br>
   이 경우, 사용자는 메뉴 오브젝트와 상호작용을 하고, 메뉴 오브젝트가 제공하는 서비스를 이용합니다.<br>
   그리고 다시 esc를 누르면 오브젝트를 반납하는데, 만약 이전에 상호작용하던 오브젝트가 있으면 그 오브젝트로 상호작용 오브젝트를 되돌립니다.<br>
   상호작용 오브젝트의 switching이라 볼 수 있습니다.

4. ### 몬스터 AI 코드와 애니메이션 간 충돌
   숲 스테이지의 보스 몬스터의 공격 패턴이 의도한대로 움직이지 않는 버그가 있었습니다.<br>
   한참 그 원인을 몰라서 일단 남겨두고 다음 작업으로 넘어갔었는데, 화산 스테이지의 보스 몬스터를 작업한 뒤 문제를 알았습니다.<br>
   <br>
   제가 작성한 몬스터 AI는 실행 시간부터 다음 애니메이션 실행 등, 대부분의 요소가 제가 작성한 프로그램 코드에 의해 제어됩니다.<br>
   그런데 애니메이터 시스템을 이용해서 실행 시간이나 스테이트 트랜지션 제약 등을 추가로 걸어놓으니 어느 순간 타이밍이 조금이라도 어긋나면<br>
   둘이 충돌이 나서 의도대로 움직이지 않는 버그가 발생한 것입니다.<br>
   <br>
   애니메이터 시스템의 제약을 필요한 것만 남기고 풀어주는 것으로 해결하였습니다.

<hr>

## 앞으로 이 프로젝트는 어떻게 될 것인가

최적화 작업 위주로 진행될 것 같습니다. GC나, 멀티 스레드같은 최적화를 진행하여 부하를 줄일 계획입니다.<br>
<br>
그 다음은 바다 스테이지를 추가하고자 생각하고 있습니다.
