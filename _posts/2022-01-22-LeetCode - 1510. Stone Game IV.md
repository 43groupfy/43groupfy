---
title: LeetCode - 1510. Stone Game IV
author: Pig
date: 2022-01-22 20:55:00 +0800
categories: [Algorithm, LeetCode]
tags: [coding]
layout: post
current: post
class: post-template
subclass: 'post'
navigation: True
cover:  assets/img/post_images/coding_cover.jpg
---

### **Idea**

Two conditions for victory assuming perfectly optimal gameplay

1. The current number of stones is 1 higher than a perfect square(e.g. 2, 5, 10, 17...)
2. A stone count that does not guarantee victory for the opponent can be reached by subtracting a perfect square number of stones

Given these two conditions, a dynamic programming approach is taken with an array to memoize the result for all possible number of stones less than n.

- Initialize the memoization array with default False value.
- Then traverse the array starting from 1 stone case, and check if the current case meets the conditions for victory.
- Return the last value of the array

### Pig Code

```python
class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False for _ in range(n)]
        for i, val in enumerate(dp):
            if self.isSquare(i+1):
                dp[i] = True
            else:
                for j in range(1, int((i+1)**0.5)+1):
                    if not dp[i-j**2]:
                        dp[i] = True
                        break
        return dp[-1]

    def isSquare(self, n):
        root = n**0.5
        return int(root) == root
```

### Good Code(Python)
```python
def winnerSquareGame(self, n):
        dp = [False] * (n + 1)
        for i in xrange(1, n + 1):
            dp[i] = not all(dp[i - k * k] for k in xrange(1, int(i**0.5) + 1))
        return dp[-1]
```