---
title: 위치찾기 
author: Ju Han Lee
date: 2020-12-29 08:00:00 +0900
categories: [Exhibition,2020년]
tags: [post,juhan]     # TAG names should always be lowercase, 띄어쓰기도 금지 
---

------------------------------------------
# 설명

### 위치 찾기 

입력받은 거리 차이를 이용하여 신호의 위치를 찾아내는 기술

### 상세

기존의 기술은 대체적으로 센서와 신호 발생원의 거리를 이용하여 신호, 혹은 센서의 위치를 파악한다.

하지만 거리를 특정할 수 없는 상황에서 기존의 방식은 많은 문제가 발생할 수 있다.

따라서 거리를 알 수 없고, 반대로 거리의 차이를 알 수 있다면, 거리의 차이를 이용하여 위치를 특정하는 방법이다.
 

-----
### 이론

신호 발생원이 어느 한 위치에 있다.

적어도 5개의 센서가 존재하며, 센서의 위치는 알고있으며 각 센서는 신호가 들어온 시간을 기록한다.

각 센서에 들어온 시간의 차이를 이용하여 거리의 차이를 계산한다.

계산된 거리의 차이를 이용하여 센서가 신호가 발생한 위치를 파악한다.

### 수학적 이론

N+1개의 점으로 만들 수 있는 최대의 bais 갯수는 N개

기준점으로부터 한 점까지의 거리를 r이라고 했을 때, 점의 위치는 (i[1],i[2],i[3],...,i[N],r)

따라서 N+2개의 점으로 위치를 특정할 수 있다.


### 연산에 사용한 수식

신호의 위치 (x,y,z)

각 센서의 위치 p[0]:(0,0,0), p[1]:(u,0,0), p[2]:(0,u,0), p[3]:(0,0,u), p[4]:(u,u,u)

각 센서로 신호가 들어온 시간 t[0:4]

신호의 전파속도 k

신호와 센서 사이의 거리 d[k]=k*(t[0]-t[k+1])

x = d[0]*(d[0]*d[1]+d[0]*d[2]+d[1]*d[2])/(u*(d[3]-d[0]-d[1]-d[2])) + d[0]*(d[1]+d[2]+d[3])/(2*u) +u/2

y = d[1]*(d[0]*d[1]+d[0]*d[2]+d[1]*d[2])/(u*(d[3]-d[0]-d[1]-d[2])) + d[1]*(d[0]+d[2]+d[3])/(2*u) +u/2

z = d[2]*(d[0]*d[1]+d[0]*d[2]+d[1]*d[2])/(u*(d[3]-d[0]-d[1]-d[2])) + d[2]*(d[0]+d[1]+d[3])/(2*u) +u/2



-----
#구현

### c++을 이용한 구현

선행처리기를 통해 x,y,z,unit을 결정할 수 있다.

저장된 x,y,z,unit을 이용하여 distanceCal 함수를 통해 거리를 구한다.

구한 거리를 이용하여 수식을 이용하여 다시 x,y,z의 값을 구한다.


### verilog를 이용한 구현

거리의 차이를 32비트 signed 정수 인풋(distance0~4)으로 받는다.

받은 인풋을 연산모듈을 이용하여 계산한다.

계산한 결과값은 32비트 signed 정수로 출력한다.

다만 베릴로그의 경우 아직 구현 중에 있으며 이른 시일 내로 완성할 수 있을 것으로 보인다.

<a href='https://github.com/SoShymKing/locationCheck'>소스코드</a>