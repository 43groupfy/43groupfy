---
title: "[C++] BOJ 16493 최대 페이지 수"
excerpt: "BOJ 16493 최대 페이지 수에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-12
last_modified_at: 2022-02-12
mainfont: Bareun_hipi
---

# [C++] BOJ 16493 최대 페이지 수

## 문제

[BOJ 16493 최대 페이지 수](https://www.acmicpc.net/problem/16493)

## 풀이

dp문제이다. 나는 상태공간을 `dp[chap][d] = 현재 chap 챕터위치에 있고 d요일 동안 읽었을 때 읽을 수 있는 최대 페이지 수`로 설정했다.
chap가 m일 때 d가 n보다 크다면 절대 답이 되어선 안되므로 적당히 작은 값을 리턴해주고 아닐 경우 0을 리턴해준다.

처음엔 `if (d > n) return -1e9;` 코드를 빼먹었었는데 WA가 났다. chap < m인데 d가 n보다 커졌을 때 `dp[chap][d]`를 조회하려 하니 문제가 생겨서 그런 것 같다.

## 코드

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef pair<int, int> pii;

pii arr[200];
int n, m;
int dp[20][201];

int go(int chap, int d) {
    if (chap == m) {
        if (d > n) return -1e9;
        return 0;
    }
    if (d > n) return -1e9;
    if (dp[chap][d] != -1) return dp[chap][d];
    int ret = 0;
    ret += max(go(chap+1, d+arr[chap].first) + arr[chap].second, go(chap+1, d));
    return dp[chap][d] = ret;
}

int main() {
    memset(dp, -1, sizeof(dp));
    scanf("%d %d", &n, &m);
    for(int i = 0; i < m; i++) {
        scanf("%d %d", &arr[i].first, &arr[i].second);
    }
    printf("%d", go(0, 0));
}
```
