---
layout: post
title: "Redux"
date: 2020-11-18 11:20:30  +0800
categories: [TIL, 2021년 01월]
tags: [TIL]
---

Finally I am starting write something on my new github blog. I thought it would be a good way to practice. Anyway, let's get started.

# Redux
Redux is a predictable state container for JavaScript apps.
It helps you write applications that behave consistently, run in different environments (client, server and native), and are easy to test. We can use Redux together with React, or with any other view library. It's tiny(just 2kB, including dependencies), but has a large ecosysyem of add-ons available.
We need to know about the 3 main principles of Redux.
1. Single source of truth + Redux is a state conatainer, it stores    
   all of your state in one place
2. Changes are made with pure functions
3. State is read-only

#### 1
The **global state** of our application is stored as an object inside a single **store**. Any given piece of data should only exist in one location, rather than being duplicated in many places.  
Redux supplies us a handy function called `createStore()`
Here we create the store that will hold all our state.

#### 2 
State can only be changed by a pure function called a **reducer**. 
To create this connection we will pass in our reducer to createStore()  
`var store = createStore(reducer)`
It gets more complicated when you have more reducers but at the core, the store now has a reducer attached to it.

#### 3 
Once we have a store that is created with store = createStore(reducer), the new store we created has a method called dispatch. Remember the only way we can change the state is to dispatch an action!  
`store.dispatch(action)`  

Following is a very basic and limited implementation of Redux's createStore(). 

```js
createStore = (reducer) => {      
  let state;      
// dispatch method       
  dispatch = (action) => {      
    state = reducer(state, action)  
  }      
  return {dispatch}        
}  
```  

The reducer is passed in to the createStore and it becomes set in our dispatch method. And when we call the dispatch method it takes in an action and it sets a new state based on what reducer will return.

####What is an Action? What is a Reducer?   
An **Action** is a plain JS object that has a `type` field. We can think of an Action as an event that describes something that happened in the application.    
The `type` field should be a string that gives action a desciptive name, like `"todos/todoAdded"`. We usually write that type string like `"domain/eventName"`, where the first part is the feature or category that this action belongs to, and the second part is the specific thing that happened.  
```js
const addTodoAction = {  
  type: 'todos/todoAdded',  
  payload: 'Buy milk'  
}  
```
A **reducer** is a function that receives the current `state` and an `action` object, decides how to update the state if necessary, and returns the new state: `(state, action) => newState`. **You can think of a reducer as an event listener which handles events based on the received action (event) type.**  
-"Reducer" functions get their name because they're similar to the kind of callback function you pass to the `Array.reduce()` method.  

Reducers must always follow some specific rules:   
- They should only calculate the new state value based on the state and action arguments  
- They are not allowed to modify the existing `state`. Instead, must make immutable updates, by copying the existing `state` and makin changes to the copied values.  
- They must not do any asynchronous logic, calculate random values, or cause other "side effects"  

The logic inside reducer functions typically follows the same series of steps:  
- Check to see if the reducer cares about this action  
  * if so, make a copy of the state, update the copy with new values, and return it  
- Otherwise, return the existing state unchanged  
Following is a example of a reducer, showing the steps that each reducer should follow  

```js
const initialState = { value: 0 }  

function counterReducer(state = initialState, action) {  
  // Check to see if the reducer cares about this action  
  if (action.type === 'counter/incremented') {  
    // If so, make a copy of `state`  
    return {  
      ...state,  
      // and update the copy with the new value  
      value: state.value + 1  
    }      
  }     
  // otherwise return the existing state unchanged  
  return state  
}    
```

Reducers can use any kind of logic inside to decide what the new state should be: `if / else`, `switch`, loops and so on.    

The action that we pass into a reducer will determine how the state will be changed depending on the type.  

##Store  
The curent Redux application stete lives in an object called the **store**.  
The store is created by passin in a reducer, and has a method called `getState` that returns the current state value:  

```js
import { configureStore } from '@reduxjs/toolkit'  

const store = configureStore({ reducer: counterReducer })  

console.log(store.getState())  
// {value: 0}  
```

##Dispatch  
The Redux store has a method called `dispatch`.  
**The only way to update the state is to call `store.dispatch()` and pass in an action object.** The store will run its reducer function and save the new state value inside, and we can call `getState()` to retrieve the updated value:  

```js
store.dispatch({ type: 'counter/incremented' })  

console.log(store.getState())  
// {value: 1}  
```
**You can think of dispatching actions as "triggering an event"** in the application. Something happened, and we want the store to know about it. Reducers act like event listeners, and when they hear an action they are interested in, they update the state in response.  

##Selectors
**Selectors** are functions that know how to extract specific pieces of information from a store state value. As an appliction grows bigger, this can help avoid repeating logic as different parts of the app need to read the same data:  

```js
const selectCounterValue = state => state.value  

const currentValue = selectCounterValue(store.getState())  
console.log(currentValue)  
// 2  
```

*###SUMMARY*
- Redux's intent can be summarized in three principles  
    *Global app state is kept in a single store  
    *The store state is read-only to the rest of the app  
    *Reducer functions are used to update the state in response to actions  
- Redux uses a "one-way data flow" app structure  
    * State describes the condition of the app at a point in time, and UI renders based on that state  
    * When something happens in the app:  
      + The UI dispatches an action  
      + The store runs the reducers, and the state is updated based on what occurred  
      + The store notifies the UI that the state has changed  
    * The UI re-renders based on the new state  

...thanks to David Thai(https://medium.com/@itsdavidthai/redux-an-explanation-for-beginners-957f268e7382)...