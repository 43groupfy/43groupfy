---
title: "[C++] BOJ 1167 트리의 지름"
excerpt: "BOJ 1167 트리의 지름에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-10
last_modified_at: 2022-02-10
mainfont: Bareun_hipi
---

# [C++] BOJ 1167 트리의 지름

## 문제

[BOJ 1167 트리의 지름](https://www.acmicpc.net/problem/1167)

## 풀이

처음엔 각 노드마다 DFS를 진행해 주었다. 하지만 시간복잡도가 O(N^2)이여서 시간초과가 났다.

찾아보니 선형시간 안에 트리의 지름을 구하는 방법이 있었다.

임의의 정점에서 거리가 가장 먼 정점 A를 찾는다. A에서 거리가 가장 먼 정점 B를 찾는다. 트리의 지름은 A와 B사이의 거리이다. 이에 대한 증명은 [여기](https://blog.myungwoo.kr/112)를 통해 확인하면 될 것 같다.

## 코드

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int, int> pii;

int n, ans = 0, nxt;
vector<pii> graph[100000];
int vis[100000];

void go(int t, int sum) {
    vis[t] = 1;
    for(pii i : graph[t]) {
        if (vis[i.first]) continue;
        go(i.first, sum + i.second);
    }
    if (sum > ans) {
        nxt = t;
        ans = sum;
    }
}

int main() {
    scanf("%d", &n);

    for(int a, b, t, i = 0; i < n; i++) {
        scanf("%d", &a);
        a--;
        while (1) {
            scanf("%d", &b);
            if (b == -1) break;
            b--;
            scanf("%d", &t);
            graph[a].push_back({b, t});
            graph[b].push_back({a, t});
        }
    }

    go(1, 0); // 1에서 가장 거리가 먼 노드 찾기
    memset(vis, 0, sizeof(vis));
    ans = 0;
    go(nxt, 0);
    printf("%d", ans);
}
```
