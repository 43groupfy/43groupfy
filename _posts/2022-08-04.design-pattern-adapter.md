---
title: "디자인 패턴 - Adapter 패턴에 대해 알아보자"
date: 2022-08-04 00:56:00 +0900
categories: [디자인패턴]
tags: [디자인패턴, Adapter 패턴]
---

# 디자인 패턴 - Adapter 패턴에 대해 알아보자

## 0. 소개

이번 주는 Adapter 패턴에 대해 내가 발표를 하기로 했다. 발표하기 전 정리한 것들을 블로그에 남기고자 한다.

## 1. Adapter 패턴이란?

- **이미 제공되어 있는 것**과 **필요한 것** 사이의 차이를 없애주는 디자인 패턴이다.
- **특정 클래스 인터페이스**를 **클라이언트에서 요구하는 다른 인터페이스**로 변환한다.
- Wrappter 패턴이라고도 부른다.

![sequence diagram](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/870594ef-f523-47cf-a15f-48c97523529d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220804%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220804T072049Z&X-Amz-Expires=86400&X-Amz-Signature=98d10a2d12f89eab038f5e66dc33f12fc1fa31c874fe5842f8be0185d61f3a7b&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

## 2. Adapter 패턴의 등장인물

![adapter](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f488ca5a-2a12-4e82-8289-32f8f6c70ba3/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220804%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220804T072205Z&X-Amz-Expires=86400&X-Amz-Signature=b118c76b7dfb5647b4a51de232d8a6b56e99fce4df87084d3c908c5beaf956c1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- Client

  - Target 역할의 메소드를 사용해서 일을 한다.

- Target

  - Client는 Target을 통해 Adaptee를 사용할 수 있다.
  - 지금 필요한 메소드를 결정한다.

- **Adapter**

  - Client가 사용하려는 Target Interface와 Adaptee 중간에서 둘을 연결해주는 역할이다.
  - Adaptee 역할의 메소드를 사용해서 어떻게든 Target 역할을 만족시키기 위한 것이 Adapter 패턴의 목적이다.

- Adaptee
  - 이미 준비되어 있는 메소드를 가지고 있는 역할이다.

## 3. 객체 어댑터와 클래스 어댑터

1. 객체 어댑터
   ![객체 어댑터](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/506ee314-05bf-4878-9546-33526db89e94/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220804%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220804T072419Z&X-Amz-Expires=86400&X-Amz-Signature=3dd0480c3f71822adce9ea15c9843be02775e4b9fb76adc90eb65b3f8eb4ca7a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

2. 클래스 어댑터
   ![클래스 어댑터](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ae6b508b-5448-456f-9f26-72af9d7bacf0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220804%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220804T072502Z&X-Amz-Expires=86400&X-Amz-Signature=96028b9303dc74fc67b89de41609e0bbd9d6c854d89100e213339729ba67f82c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- 객체 어댑터는 구성으로 Adaptee에 요청을 전달하는 반면, 클래스 어댑터는 Target과 Adaptee 모두 서브클래스로 만들어서 사용한다.

책에서 소개하는 예제로 코드를 살펴보자.

[객체 어댑터 - 위임을 사용한 Adapter 패턴]
![객체 어댑터](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4c12b290-235f-4ce3-8e4a-e61fd229d76e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220804%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220804T072943Z&X-Amz-Expires=86400&X-Amz-Signature=7965b8af934a87084027e6114721bfd115a2ac3432c4e39c11e06cb5f57ee833&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- Adapter는 Adaptee로 구성되어 있다. Adapter의 몸든 요청은 Adaptee에게 위임된다.
- `PrintBanner` 클래스는 `banner` 필드에서 `Banner` 클래스의 인터페이스를 가진다.
- `printWeak`, `printStrong` 메소드에서는 `banner` 필드를 매개로 `showWithParen`, `showWithAster` 메소드를 호출한다.
- 즉, 자신이 처리하는 것이 아니라 별도의 인스턴스에게 위임하고 있다.

**Print.java**

```java
public abstract class Print {
	public abstract void printWeak();
	public abstract void printStrong();
}
```

**PrintBanner.java**

```java
public class PrintBanner extends Print {
	private Banner banner;

	public PrintBanner(String string){
		this.banner = new Banner(string);
	}

	public void printWeak() {
		banner.showWithParen();
	}

	public void printString() {
		banner.showWithAster();
	}
}
```

**Banner.java**

```java
public class Banner {
	private String string;

	public Banner (String string) {
		this.string = string;
	}

	public void showWithParen() {
		System.out.println("(" + string + ")");
	}

	public void showWithAster() {
		System.out.println("*" + string + "*");

	}
}
```

[클래스 어댑터 - 상속을 사용한 Adapter 패턴]
![클래스 어댑터](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/158a7326-f8e7-4c82-8450-16aebeba949b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220804%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220804T073319Z&X-Amz-Expires=86400&X-Amz-Signature=ba7c85d47cb5ae94b215684ad2e9bcfa81ffd734fae9c2425d306e95b5f7c8e5&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- `PrintBanner` 클래스가 `Banner`클래스를 확장해서 `showWithParen`, `showWithAster` 메소드를 상속받는다.

**Print.java**

```java
public interface Print {
	public abstract void printWeak();
	public abstract void printStrong();
}
```

**PrintBanner.java**

```java
public class PrintBanner extends Banner implements Print {

	public PrintBanner(String string){
		super(string);
	}

	public void printWeak() {
		showWithParen();
	}

	public void printString() {
		showWithAster();
	}
}

```

[Main.java]

```java
public class Main {
	public static void main(String[] args) {
		Print p = new PrintBanner("Hello");
		p.printWeak();
		p.printStrong();
	}
}
```

- Main 클래스 내에서 `PrintBanner`의 인스턴스를 Print 인터페이스형의 변수로 대입한다.
- `PrintBanner` 클래스가 어떻게 실현되고 있는지는 모른다. 따라서 Main 클래스를 변경하지 않고도 `PrintBanner` 클래스 구현을 바꿀 수 있다.

## Question

1. 두 개의 인터페이스가 달라서 호환이 안되면 하나를 바꾸던지 둘 다 바꾸면 되는거 아닌가요?

- Adaptee가 써드파티 라이브러리라면 직접적인 접근이 불가능하다. 직접적으로 접근할 수 있다고 하더라도 Adaptee 쪽에서 우리가 변경한 코드로 인해 라이브러리가 깨질 수 있다.

- Target 인터페이스를 수정한다고 했을 때도 문제가 생길 수 있다. Target 인터페이스를 다른 어딘가에서 사용하고 있다면 그 부분도 수정을 해주어야 한다. 이렇게 수정하다가 예기지 못한 오류가 발생할지도…

2. 장점이 뭔가요?

- 호환되지 않는 인터페이스를 사용하는 클라이언트를 그대로 활용할 수 있다. 이를 통해 클라이언트와 구현된 인터페이스를 분리시킬 수 있으며, 향후 해당 인터페이스가 바뀌더라도 그 변경 내역은 adapter에 캡슐화 되기 때문에 클라이언트는 바뀔 필요가 없어진다.

## 참고문헌

[Java언어로 배우는 디자인 패턴 입문](http://www.yes24.com/Product/Goods/2918928)
