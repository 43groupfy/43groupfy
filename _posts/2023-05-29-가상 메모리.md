---
title: 가상 메모리
layout: post
author: littley
date: 2023-05-29 00:00:00 +0900
categories: [CS, OS]
tags: [OS]
toc: true
toc_sticky: true
img_path: /assets/img/posts/가상메모리
---

![Untitled](Untitled.png)

하지만 이렇게 봐서는 무슨 말인지 잘 모르겠다. 가상 메모리를 이해하기 위해서는 사전 배경 지식이 필요하다! 

## 컴퓨터 기본 구조

![Untitled](Untitled%201.png)

CPU가 연산을 하려면 메모리 값을 참조해야 한다. CPU와 직접 연결되어 있는 레지스터의 저장 값에는 빠르게 참조할 수 있지만, **휘발성이 강하고 용량이 매우 작다**는 단점이 있다. 반대로 외부저장장치는 자료를 **안전하게 보관**할수 있지만 운영체제의 도움을 받아 접근해야 하기 때문에 **느리다**는 단점이 있다. 이 사이를 메꿔주는 것이 **메모리**다. 

## 프로그램이 실행된다는 것의 의미

프로그램이 실행된다는 것은 CPU가 일을 한다는 것이다. 프로그램은 DISK에 저장되어 있기 때문에, 이를 실행시키기 위해서는 프로그램의 데이터가 디스크에서 메모리로 올라와 있어야 한다. 

일반적으로 프로그램은 **이진 실행 파일** 형식으로 저장되어 있다. 프로그래머가 작성한 소스 코드를 컴파일러가 해석하고 링커가 연결하면 이진 실행 파일이 만들어진다.  우리가 컴퓨터에서 프로그램을 실행하면 이러한 이진 실행 파일이 **물리 메모리**에 올라오게 된다. 해당 파일이 실행되기 위해서는 메모리에 가져온 데이터가 프로세스 형태로 배치되어야 한다. 즉 CPU가 참조할 수 있는 형태로 물리 메모리에 올라와야 한다.

![Untitled](Untitled%202.png)

OS는 `fork()` 요청으로 프로세스를 생성하고, `exec()` 요청으로 로더를 호출한다. 

로더는 생성된 프로세스 주소 공간을 사용해서 지정된 실행 파일을 메모리에 올리는 데 사용된다. 이렇데 되면 CPU가 필요한 정보를 참조할 수 있게 된다. 

![Untitled](Untitled%203.png)

CPU는 실행파일을 실행하면 0번부터 시작하는 프로세스마다 독자적인 주소 공간을 생성한다. CPU 입장에서 바라보는 이 주소를 **논리 주소**라고 한다. 

---

## 주소 바인딩

![Untitled](Untitled%204.png)

CPU가 일을 하기 위해서는 논리 주소가 메인 메모리상에 올라와 있어야 한다. 다만 실제 물리 주소를 사용하지는 않는다. **논리 주소는 물리적 메모리의 특정 위치로 맵핑** 되는데, 이 작업을 **주소 바인딩**이라고 한다. 논리 주소와 물리 주소의 값이 같을 수도, 다를 수도 있다.

물리적 메모리 주소가 결정되는 시기에 따라 세 가지 바인딩 방법이 있다. 컴파일 타임 바인딩, 로드 타임 바인딩, **런타임 바인딩**이다. **가상메모리**를 사용하기 위해서는 런타임 바인딩을 지원해야 한다.

![Untitled](Untitled%205.png)

런타임 바인딩을 위해서는 CPU가 주소를 참조할때 마다, 주소 매핑 테이블을 이용해 바인딩을 점검해야 한다. 이를 위해서는 **기준 레지스터 및 한계 레지스터**를 알게 해주는 MMU의 지원이 필요하다.

![Untitled](Untitled%206.png)

**논리 주소 + 기준 레지스터의 값**을 이용해 데이터가 저장되어 있는 실제 물리적 주소의 값을 계산한다. 프로세스는 자신만의 고유한 주소값을 갖기 때문에, 동일한 주소값이더라도 프로세스마다 다른 데이터를 갖게 된다. 

MMU 기법에서는 문맥 교환도 기준 레지스터값을 각 프로세스에 맞게 설정한다.

---

## 시분할 방식

![녹음_2023-05-31_200213_AdobeExpress.gif](Untitled.gif)

CPU의 병렬 처리는 동시에 여러 프로세스를 실행하는 것이 아닌, 매우 짧은 시간에 프로세스를 바꿔 가면서 사용하는 것이다. 이를 **시분할 방식(TTS, Time Sharing System)**이라고 한다. 

![Untitled](Untitled%207.png)

한 CPU에 여러개의 프로그램이 올라오면, 프로세스에 할당할 물리 메모리 공간이 부족해진다. 이를 해결하기 위해 메모리 공간의 확장 영역으로 **스왑 영역**을 사용한다.

## 스왑 영역

![Untitled](Untitled%208.png)

스왑 공간은 외부저장장치에 존재하지만, 물리 메모리의 확장 개념이다. 물리 메모리에 공간이 부족하기 때문에, 실행중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려 놓는 것이다.

스왑 영역은 디스크에 존재하지만 파일시스템과는 별도로 존재한다. 파일시스템은 비휘발성이지만 메모리 공간의 확장으로 사용되기 때문에 **프로세스가 수행 중인 동안에만 일시적으로 저장**된다. 

메모리에서 스왑 영역으로의 이동을 `Swap In` 및 `Swap Out`이라고 한다. 스왑 영역도 외부저장장치에 존재하기 때문에 OS에 의해 I/O가 일어난다. 하지만 공간효율성 보다는 **시간효율성**을 우선으로 하기 때문에 일반적인 파일 시스템에 접근하는 것보다 좀 더 빠른 접근이 가능해진다.

---

## 이제 본격적으로 가상메모리에 대해 알아보자.

![Untitled](Untitled%209.png)

지금까지 설명한 내용은 실행되고 있는 프로세스의 정보가 모두 물리 메모리에 올라와 있다고 가정하고 있다. 여러 개의 프로그램을 실행하고 있는 환경에서 물리 메모리를 나눠서 쓰고 있다. 여러 개의 프로그램을 실행할 수록 한 프로그램이 사용할 수 있는 메모리가 작아진다. 

만약 다른 프로세스를 새로 올려야 해서 공간이 부족해진다면, 기존 프로세스를 스왑 영역으로 내놓고 꼭 필요한 프로세스를 물리 메모리로 올려야 한다. 이렇게 되면 스왑 영역과 물리 메모리 영역간의 I/O가 매우 빈번하게 발생한다. 심지어 물리 메모리의 크기를 벗어나는 프로세스의 경우에는 실행조차 불가능하다. 

이런 불편함 때문에 등장한 것이 바로 **가상메모리**이다. 

![Untitled](Untitled%2010.png)

좋은 프로그램일수록 자주 사용되지 않는 방어 코드나 관리 코드가 많다.  만약 필요한 내용만 물리 메모리에 올려놓을 수 있다면? 효율적으로 프로세스를 작동시킬 수 있다. 

가상메모리는 실제 물리 메모리의 부분과 개발자의 논리 메모리 개념을 분리한다. 따라서 가상메모리를 사용하면 프로세스 전체의 내용을 메모리에 올릴 필요 없이, 필요한 부분만 메모리에 올려 실행이 가능하다.

 이때 필요한 정보만 올려줄 수 있게 하는 기법이 **요구 페이징 기법**이다. 

![Untitled](Untitled%2011.png)

이 기법에서는 주소공간이 하나의 단위가 아니라, 여러개의 페이지로 나눠져 있다. 그 중에서 당장 필요한 페이지들만 물리 메모리에 가져와 사용한다. 

그렇다면 필요한 페이지가 물리 메모리에 올라와 있는 지 파악할 수 있는 방법은 무엇일까?

---

## 요구 페이징 기법

![Untitled](Untitled%2012.png)

특정 페이지 메모리 존재임을 구분하기 위해 **유무효 비트**를 사용한다. `Valid` 비트는 해당 페이지가 메모리에 있음을 의미하고, `Invalid` 비트는 해당 페이지가 메모리에 없음을 의미하며 이를 **Page fault**가 발생했다고 말한다. 이 경우에 보조 저장장치에 페이지가 있다면, 보조 저장장치에서 페이지를 가져온다.

`Invalid`일 때 상황에 대해 조금 더 자세히 동작 원리를 알아보자.

![Untitled](Untitled 1.gif)

1. CPU가 논리 메모리에서 1번지의 값에 참조를 시도한다.
2. 대응되는 페이지 테이블을 보니 `Invalid` 비트로 설정되어 있다. 즉 해당 내용이 물리적 메모리에 없다는 의미이고, Page fault가 발생했다.
3. CPU 제어권이 OS에게 넘어가게 되고 스왑 영역에서 해당 페이지를 참조한다.
4. 물리 메모리의 빈 페이지에 해당 페이지가 올라가게 된다.

요구 페이징 기법을 사용하면 상대적으로 큰 저장 공간인 스왑 영역을 활용하여 프로세스마다 가상의 주소 공간을 확보하고, 필요한 페이지만 물리 메모리에 올려 사용함으로써 더 효과적으로 물리 메모리를 사용할 수 있게 된다. 운영체제 또한 프로그램이 물리적 메모리의 크기를 고려할 필요없이 자기 자신만의 메모리를 사용하는 것을 지원해준다.

---

## 마무리

정리해보자면 가상 메모리를 사용하는 이유 및 장점은 다음과 같다.

1. **사용자 프로그램이 물리 메모리의 제약에서 벗어난다.**

    → 사용자 프로그램이 물리 메모리보다 커져도 되고, 프로그래머는 물리 메모리 크기를 신경쓰지 않아도 되기 때문에 실제 해결하고자 하는 문제에 집중이 가능하다.
    
2. **각 프로그램이 더 작은 메모리를 차지하기 때문에 더 많은 프로그램을 동시 수행 가능하다.**
    
    → 프로세스 당 메모리 사용량이 감소하고, 더 많은 프로세스를 수용 가능하다.
        응답시간은 늘지 않으면서 CPU 이용률과 처리률이 높아진다.
    
3. **프로그램을 메모리에 올리고 swap 하는데 필요한 IO 횟수가 줄어든다.**
    
    → IO가 적게 일어나므로 더 빨리 실행이 가능하다.
    

---

## 참고자료

[[10분 테코톡] 🧚🏻 배럴의 가상 메모리](https://www.youtube.com/watch?v=5pEDL6c--_k)

OS에 따라 페이징 기법을 사용하지 않고, 큰 메모리를 요구하는 프로세스를 죽여버리는 OS도 있다.