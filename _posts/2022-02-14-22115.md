---
title: "[C++] BOJ 22115 창영이와 커피"
excerpt: "BOJ 22115 창영이와 커피에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-14
last_modified_at: 2022-02-14
mainfont: Bareun_hipi
---

# [C++] BOJ 22115 창영이와 커피

## 문제

[BOJ 22115 창영이와 커피](https://www.acmicpc.net/problem/22115)

## 풀이

재귀 풀이에서는 `dp[ix][t] = ix번째 커피까지 봤을 때 t만큼의 카페인을 섭취하기 위해 마셔야 할 커피의 최소 개수`로 정의했다.
반복문 풀이에서는 `dp[t] = t만큼의 카페인을 섭취하기 위해 마셔야 할 커피의 최소 개수`로 정의했다.

## 코드 - 재귀

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int n, k;
int arr[100];
int dp[100][100001];

int go(int ix, int t) {
    if (ix == n) {
        if (t == k) return 0;
        return 1e9;
    }
    if (t > k) return 1e9;
    if (dp[ix][t] != -1) return dp[ix][t];
    int ret = min(go(ix + 1, t), go(ix + 1, t + arr[ix]) + 1);
    return dp[ix][t] = ret;
}

int main() {
    memset(dp, -1, sizeof(dp));
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i++) scanf("%d", &arr[i]);
    int ans = go(0, 0);
    if (ans >= 1e9) printf("-1");
    else printf("%d", ans);
}
```

## 코드 - 반복문

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
int n, k;
int arr[100];
int dp[100001];

int main() {
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i++) scanf("%d", &arr[i]);
    for(int i = 1; i <= k; i++) dp[i] = 1e9; // dp배열을 임의의 큰 수로 초기화한다.

    for(int i = 0; i < n; i++) {
        // j양의 카페인을 먹기 위해 i번째 커피를 먹는 것이 이득이라면 값을 갱신시켜준다.
        for(int j = k; j >= arr[i]; j--) dp[j] = min(dp[j], dp[j-arr[i]] + 1);
    }
    if (dp[k] == 1e9) printf("-1");
    else printf("%d", dp[k]);
}
```
