---
title: "[JS] this 이해하기"
date: 2022-06-30 00:56:00 +0900
categories: [JS]
tags: [JS, this]
---

# [JS]] this 이해하기

### 참고서적

[코어 자바스크립트](http://www.yes24.com/Product/Goods/78586788)

## 0. 소개

소마 팀원들과 JS 스터디를 시작했다. (사실 이번이 세번째이다.)
<br>
관련 내용을 정리하고 기록해 보고자 한다.

## 1. this

**자바스크립트에서 `this`는 실행 컨텍스트가 생성될 때 함께 결정된다.**

- 실행컨텍스트는 함수를 호출할 때 생성된다.
- 즉, `this`는 함수를 호출할 때 결정된다.
- 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라진다.

## 2. 전역 공간에서 `this`

- 전역 컨텍스트를 생성하는 주체는 전역 객체이다.
- 따라서 전역 공간에서 this는 전역 객체를 가리킨다.
- 전역 객체는 JS 런타임 환경에 따라 다른 이름과 정보를 가진다.
  ex) 브라우저 환경에서 전역 객체 : window

**자바스크립트의 모든 변수는 특정 객체의 property로서 동작한다.**

```javascript
var a = 1;
console.log(a); // 1
console.log(window.a); // 1
console.log(this.a); // 1
```

- 위 코드처럼 사용자가 var 연산자로 변수를 선언하더라도 a 는 LexicalEnvironment의 property로 저장됨.

a를 직접 호출할 때 과정

1. 스코프 체인에서 a를 검색한다.
2. 마지막에 도달하는 전역 스코프의 LexicalEnvironment의 property a를 발견한다.
3. 해당 값을 반환한다.

**QUIZ**

```javascript
var a = 3;
window.b = 2;
console.log(a, window.a, this.a); // ? ? ?
console.log(b, window.b, this.b); // ? ? ?

window.a = 7;
b = 1;
console.log(a, window.a, this.a); // ? ? ?
console.log(b, window.b, this.b); // ? ? ?
```

**그렇다면 삭제하는 과정에서는 어떻게 될까?**

```javascript
var a = 1;
delete window.a; // false
console.log(a, window.a, this.a); // 1 1 1
```

```javascript
window.a = 1;
delete window.a; // true
console.log(a, window.a, this.a); // Uncaught ReferenceError: a is not defined
```

- 처음부터 전역객체의 property로 할당한 경우에는 삭제가 되지만 전역변수로 선언한 경우 삭제되지 않는다.
- 사용자가 의도치 않게 삭제하는 것을 방지하는 차원.
- 즉, 전역변수를 선언하면 JS 엔진이 이를 자동으로 전역객체의 property로 할당하면서 해당 property의 configurable 속성을 false로 정의한다.

## 3. 메서드로서 호출할 때 메서드 내부에서의 `this`

우선 함수와 메서드의 차이를 살펴보자.

함수를 실행하는 방법에서 가장 일반적인 방법으로는 함수로서 호출하는 경우와 메서드로서 호출하는 경우가 있다. 프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치이다.

여기서 이 둘을 구분할 수 있는 유일한 차이는 독립성이다. 함수는 그 자체로 독립적인 기능을 수행하지만, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.
함수로서 호출과 메서드로서 호출은 함수 앞에 점이 있는지의 여부로 간단하게 구분 가능하다.

```javascript
var func = function (x) {
  console.log(this, x);
};
func(1); // Window { ... }

var obj = {
  method: func,
};

obj.method(2); // { method: f } 2

var obj2 = {
  method: function (x) {
    console.log(this, x);
  },
};
obj2["method"](2); // { method: f } 2
```

method 내부에서의 this에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우, 호출 주체는 함수명 앞의 객체이다.

## 4. 함수로서 호출할 때 함수 내부에서의 `this`

this는 **호출한 주체에 대한 정보**가 담긴다.
함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 코드에 관여해 실행한 것이다. 따라서 어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않으며 함수에서의 this는 전역 객체를 가리킨다.

**QUIZ**

```javascript
var quiz = {
  outer: function () {
    console.log(this); // Q1
    var innerFunc = function () {
      console.log(this); // Q2 Q3
    };
    innerFunc();

    var quiz2 = {
      innerMethod: innerFunc,
    };
    quiz2.innerMethod();
  },
};
quiz.outer();
```

**Answer**
Q1 : quiz
Q2 : window
Q3 : quiz2

```javascript
var quiz = {
  // 1. quiz 객체 생성
  outer: function () {
    // 3. quiz.outer 함수 실행 컨텍스트 생성 -> 호이스팅 -> 스코프 체인 정보 수집 -> method로서 호출했으므로 this에 quiz가 바인딩됨
    console.log(this); // // 4. quiz 객체 정보 출력
    // 5. 호이스팅 된 innerFunc에 익명함수 할당
    // 6. innerFunc 함수 실행 컨텍스트 생성 및 호이스팅 -> 스코프 체인 수집 -> 함수로서 호출했으므로 this가 지정되지 않았고 자동으로 스코프 체인상의 최상위 객체인 전역객체가 바인딩 됨
    var innerFunc = function () {
      console.log(this); // 7. window 객체 정보 출력 & 10. quiz2 객체 정보 출력
    };
    innerFunc(); // 6. innerFunc 호출

    var quiz2 = {
      // 7. 호이스팅된 변수 quiz2(객체)
      innerMethod: innerFunc, // 9. innerMethod 실행 컨텍스트 생성 -> 메서드로서 호출했으므로 this에는 마지막 점 앞의 객체인 quiz2가 바인딩 됨
    };
    quiz2.innerMethod(); // 8. quiz2.innerMethod 호출
  },
};
quiz.outer(); // 2. quiz.outer 호출
```

**ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 해결하고자 this를 바인딩하지 않는 화살표 함수(arrow function)을 새로 도입했다.** 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어 상위 스코프의 this를 그대로 활용할 수 있다고 한다.
