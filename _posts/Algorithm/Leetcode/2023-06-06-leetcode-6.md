---
title:  "6. Zigzag Conversion"
excerpt: "6. Zigzag Conversion"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-06-06
last_modified_at: 2023-06-06
---
***
## Z**igzag Conversion**

The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

```
P   A   H   N
A P L S I I G
Y   I   R

```

And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:

```
string convert(string s, int numRows);

```

**Example 1:**

```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

```

**Example 2:**

```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I

```

**Example 3:**

```
Input: s = "A", numRows = 1
Output: "A"

```

**Constraints:**

- `1 <= s.length <= 1000`
- `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
- `1 <= numRows <= 1000`

### 1. 과정

- 거꾸로 된 ‘N’자 모양을 그리면서 지그재그로 단어들을 주어진 열의 개수만큼 2차원 배열 형태로 나열한 후, 선택한 열에 있는 단어를 출력하는 문제이다
- numRow를 한 개씩 늘리면서 규칙을 찾아보자
    - numRow = 3이면, 3131313…으로 열이 구성된다
    - numRow = 4이면, 4114114…으로 열이 구성된다
    - numRow = 5이면, 511151115… 으로 열이 구성된다.
    
- 다행히도, 우리는 일직선을 이루는 문자의 번호가 규칙적인 것을 알 수 있다.
    
    
    - 다시 한 번 지그재그 모양을 잘 살펴보면
        
        numRow = 3일 때,  1 2 3 / 4 / 5 6 7 / 8 / 9 10
        
        numRow = 4일 때, 1 2 3 4 / 5 6 / 7 8 9 10 / 11 12 /13 14 15 16
        
        numRow = 5일 때,  1 2 3 4 5 / 6 7 8 / 9 10 11 12 13…
        
        가운데 대각선을 이루는 번호의 개수는 1, 1, 1, 2, 3, 4, 5 로, numRow가 1과 2일 때를 제외하면 규칙적으로 증가하며,
        
        일직선을 이루는 문자 번호도 (1→5→8/1→7→13/1→9→17) 와 같이 numRow-1*2의 사이클 만큼 규칙적으로 증가함을 알 수 있다.

		즉, 행에 들어가야할 문자열을 사이클에 맞춰서 넣어주면 된다.

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows <= 1) {
            return s;
        }
        std::vector<std::string> list(numRows, "");
        int currentLine = 0;
        bool reachedEdge = true;

        for (int i = 0; i < s.length(); ++i) {
            if (currentLine == 0 || currentLine == numRows - 1) {
                reachedEdge = !reachedEdge;
            }
            list.at(currentLine) += s.at(i);
            if (!reachedEdge) {
                currentLine++;
            } else {
                currentLine--;
            }
        }

        std::string result;
        for (int i = 0; i < numRows; ++i) {
            result += list.at(i);
        }
        return result;
    }
};

```

***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}