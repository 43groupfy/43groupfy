---
title:  "121. Best Time to Buy and Sell Stock"
excerpt: "121. Best Time to Buy and Sell Stock"

categories:
  - Leetcode
tags:
  - [Leetcode]

toc: true
toc_sticky: true
 
date: 2023-08-31
last_modified_at: 2023-08-31
---

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
***
### **문제 설명**

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return *the maximum profit you can achieve from this transaction*. If you cannot achieve any profit, return `0`.

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

```

**Example 2:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.

```

**Constraints:**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

### 과정

75gift의 Array 문제 중 하나다.

[New Year Gift - Curated List of Top 75 LeetCode Questions to Save Your Time](https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU)

배열 내의 값은 해당 배열 index 날의 주식 값으로, 가장 많은 차익을 실현할 수 있는 경우를 구하는 문제이다.

즉,

1) 최대 값은 최소 값보다 배열 앞 쪽에 위치해야 한다.

2) 최대 값에 산 주식은 언젠가 팔아야 한다.

라는 조건들이 자동으로 딸려오게 된다.

 

단순하게 배열 전체를 탐색해서 최대 값과 최소 값을 찾는 방법이 있겠지만, 십중팔구 시간 내에 못할 게 뻔하니,

두 번째로 생각나는, 첫 값을 최소 값으로 상정하고 만나는 값과 비교해가면서 가장 큰 차이가 나는 값을 max값으로 넣어주면서 순회하는 

방법이 있겠다.

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max  = 0, min = prices[0];
        for(int i=0;i<prices.size();i++){
            if(prices[i]<min){
                min = prices[i];
            }
            if((prices[i]-min)>max){
                max = prices[i]-min;
            }
        }
        return max;
    }
};
```

## 결과

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eb2c59a9-68b1-445e-b829-19e5b61a6e90/%EC%BA%A1%EC%B2%98.png)

## 다른 사람의 풀이

### DP 풀이

무려 DP 풀이가 있다!

아니 어떻게 이게 DP가 되지? 하고 한참이나 들여다보고 가까스로 이해를 했다

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX, maxProfit = 0;
        for(int i=0; i<prices.size();i++){
            maxProfit = max(maxProfit, prices[i]-minPrice);
            minPrice = min(minPrice,prices[i]);            
        }
        return maxProfit;
    }
};
```
***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}