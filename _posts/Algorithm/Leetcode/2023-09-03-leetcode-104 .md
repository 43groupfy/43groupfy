---
title:  "104. Maximum Depth of Binary Tree"
excerpt: "104. Maximum Depth of Binary Tree"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-09-03
last_modified_at: 2023-09-03
---
***
[LeetCode - The World's Leading Online Programming Learning Platform](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

## 문제 설명

**[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)**

**Easy**

11.7K

192

Companies

Given the `root` of a binary tree, return *its maximum depth*.

A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

!https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg

```
Input: root = [3,9,20,null,null,15,7]
Output: 3

```

**Example 2:**

```
Input: root = [1,null,2]
Output: 2

```

**Constraints:**

- The number of nodes in the tree is in the range `[0, 104]`.
- `100 <= Node.val <= 100`

## 과정

Binary Tree 의 최대 깊이를 구하는 문제다.

Binary Tree의 최대 Depth를 구하는 방법은 기본적으로 DP 방식으로, 양 옆에 달려 있는 Sub Tree를 탐색해가면서, Sub Node가 존재하면 Depth의 수를 추가해가면서, 누적된 Depth 값 중 가장 높은 Depth 값을 출력하면 된다.

트리 순회에서는 DP는 거의 언제나 딸려나오니깐 다시 한 번 복습을 하게 되었다.

## 코드

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //root가 없으면 0
        if(!root) return 0;
        //child node가 하나라도 있으면(nullptr이 아닐 때까지) DP 수행 
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```
***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}