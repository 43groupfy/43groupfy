---
title:  "2. Add Two Numbers"
excerpt: "2. Add Two Numbers"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-06-03
last_modified_at: 2023-06-03
---
***
## Add Two Numbers

Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have ***exactly* one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

![addtwonumber1.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/429a89bd-f872-49b9-8f7e-cca4e44f94ec/addtwonumber1.jpg)

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

```
Input: l1 = [0], l2 = [0]
Output: [0]
```

```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

**Constraints:**

- The number of nodes in each linked list is in the range `[1, 100]`.
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros.

### 과정

  쉽게 생각해서 더하기 문제이다. 그런데 링크드 리스트에 들어있는.

1의 자리부터 시작하는 링크드 리스트끼리 더하는 거니,

0) 합 값을 집어넣을 새로운 리스트 노드 생성

반복

1) 각 list의 node끼리 덧셈

이전 연산으로 나온 carry 값+l1 값 + l2 값

carry 값 연산(합을 10으로 나누기)

2) 새로운 노드 생성

새로운 노드의 val에 carry를 뺀 나머지 값 저장

l1, l2 다음 노드로 이동 ( 없으면 nullptr 처리)

가 되겠다.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* d_head = new ListNode(0);
        ListNode* cur = d_head;
        int carry = 0;
        int l1_num = 0;
        int l2_num = 0;
        while(l1!=NULL||l2 != NULL || carry != 0)
        {
            int l1_num = l1 ? l1->val :0;
            int l2_num = l2 ? l2->val :0;
            int sum = carry + l1_num +l2_num;
            carry = sum/10;
            cur->next = new ListNode(sum%10);
            cur = cur->next;
            l1 = l1 ? l1->next : nullptr;
            l2 = l2 ? l2->next : nullptr;
        }
        return d_head->next;
    }
};
```

통과는 했지만…

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/028af4a9-83ba-4ee2-a469-f48e964b5d82/%EC%BA%A1%EC%B2%98.png)

## 가장 추천 많이 받은 풀이

https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists/

- **Time Complexity :-** BigO(max(N, M)) where N is length of l1 & M is length of l2
- **Space Complexity :-** BigO(max(N,M))

***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}