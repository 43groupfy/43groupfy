---
title:  "10. Regular Expression Matching"
excerpt: "10. Regular Expression Matching"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-09-04
last_modified_at: 2023-09-04
---
***
문제 링크
https://leetcode.com/problems/regular-expression-matching/

## 1. 문제 설명

Hard

11.3K

1.9K

Companies

Given an input string  `s` and a pattern  `p`, implement regular expression matching with support for  `'.'`  and  `'*'`  where:

- `'.'` Matches any single character.
- `'*'` Matches zero or more of the preceding element.

The matching should cover the  **entire**  input string (not partial).

**Example 1:**

**Input:** s = "aa", p = "a"
**Output:** false
**Explanation:** "a" does not match the entire string "aa".

**Example 2:**

**Input:** s = "aa", p = "a*"
**Output:** true
**Explanation:** '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

**Example 3:**

**Input:** s = "ab", p = ".**"
**Output:** true
**Explanation:** ".*" means "zero or more (*) of any character (.)".

**Constraints:**

- `1 <= s.length <= 20`
- `1 <= p.length <= 20`
- `s` contains only lowercase English letters.
- `p` contains only lowercase English letters, `'.'`, and `'*'`.
- It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.

## 2. 과정

### 1) 생각 풀어보기

DP 의 첫 Hard 문제이다.
사실 문제 자체보다는 문제 지문을 이해하는데 시간이 걸렸다. 특히,

- `'.'` Matches any single character.
- `'*'` Matches zero or more of the preceding element.

부분에서 이걸 정규표현식으로 치환한다는 걸 깨닫기까지 꽤나 걸렸다. 

예를 들어,

- a* 는 a, aa, aaa, aaaa….로 표현이 되고,
- .* 는 아무 글자나 0개에서 아무 걸로나 채워도 만족하는 표현식이다.

응용해서 하나를 만들어보면

- .*b : 아무 글자로 채워도 상관 없지만, 마지막 글자는 b여야 한다.
- a*b : b, ab, aab, aaab ….. 패턴
- a = a * b  는 참이다

이 되겠다.

### 2) 알고리즘 짜보기

…1시간 동안 끙끙대다가 결국은 답지를 보고 말았다.

DP 문제인 건 파악을 했지만, 여러 개의 정규 표현식 문자에 대해서 어떻게 전개를 해나가야 하는지 작성하기가 어려웠다.

[Regular Expression Matching - Dynamic Programming Top-Down Memoization - Leetcode 10](https://www.youtube.com/watch?v=HAA8mgxlov8)

그래서 답지를 보고 해석해나가기로 하자.

당연히 정규표현식을 Tree처럼 따라가다 보면 일치하는 문자를 만날 수야 있겠다만, 그러면 주어진 문자 크기가 n일 때, O(2^n)만큼의 시간이 걸릴 것이다.

기존 문자에서 정규 표현식 문자를 붙여나가는 형식이므로, 현재 정규 표현식 문자를 계속 사용해서 문자를 붙일 지, 아니면 다음 형식으로 넘어갈 지가 핵심이므로, DP 방식으로 풀어나가면 

문제에선 정규 표현식으로 표현할 수 있는 문자 중에서 s가 전체적으로(부분적X)으로 만족이 되어야한다고 명시되어 있다.

## 3. 코드 Review

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        vector<vector<int>> dp(s.length()+1,vector<int>(p.length(),-1));
        return helper(s,p,0,0,dp);
    }
    
    bool helper(string s, string p, int i, int j,vector<vector<int>> &dp)
    {
        if(j==p.length())
            return i==s.length();
        if(dp[i][j]>=0)
            return dp[i][j];
        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]=='.' ));
        bool ans=0;
        if(j+1<p.length() && p[j+1]=='*')
        {
            ans= (helper(s,p,i,j+2,dp)|| (first_match && helper(s,p,i+1,j,dp) ));
        }
        else
        {
            ans= (first_match && helper(s,p,i+1,j+1,dp));
        }
        dp[i][j]=ans;
        return ans;
    }
};
```

예를 들어서 설명해보자

s = “aab”

p = “c * a * b ”

### 1) 초기화

- DP 를 위해서 2차원 배열 ‘dp’를 초기화한다. ‘dp’의 크기는 (주어진 문자 길이  s +1) *(정규 표현식 문자열 길이 p) 로 설정한다.

### 2) 문자열 매칭

- helper 함수를 호출하여 문자열 매칭을 시작한다.
- bool helper(string s, string p, int i, int j,vector<vector<int>> &dp) 에서 i와 j는 주어진 문자 s 와 p의 인덱스를 나타낸다.

### 3) 문자열 매칭 진행(재귀 호출)

- 현재 위치에서 **`s[i]`**와 **`p[j]`**를 비교.
    - **`s[0]`**은 "a"이고 **`p[0]`**은 "c"이므로 **`first_match`**가 **`false`**
    
- **`p[j+1]`**을 확인
    - **`p[1]`**은 "*" 문자이므로 **`ans`**를 계산하기 위해 **`helper`**를 두 번 호출한다:**`helper(s, p, 0, 2, dp)`**: "*" 다음의 문자가 0번 반복됨을 의미하므로 **`j+2`**로 이동. 결과적으로 **`ans`**는 **`true`**
    - **`helper(s, p, 1, 0, dp)`**: **`first_match`**가 **`false`**이므로 **`ans`**는 **`false`**.
    
- dp 배열 업데이트:
    - **`dp[0][0]`**에 **`ans`** 값을 저장.
    
- 재귀 호출:
    - **`helper(s, p, 0, 1, dp)`**을 호출.
    - **`first_match`**는 **`false`**.
    - **`p[1+1]`**은 "*" 문자이므로 **`helper`**를 두 번 호출:
        - **`helper(s, p, 0, 3, dp)`**: "*" 다음의 문자가 0번 반복됨을 의미하므로 **`j+2`**로 이동. 결과적으로 **`ans`**는 **`true`**.
        - **`helper(s, p, 1, 1, dp)`**: **`first_match`**가 **`false`**이므로 **`ans`**는 **`false`**.
        
- dp 배열 업데이트
    - **`dp[0][1]`**에 **`ans`** 값을 저장.
    - 
- 그림에 표시되지 않은 나머지 호출과 배열 업데이트를 반복하면 **`dp[3][5]`**에 최종 결과가 저장되고, 최종적으로 **`dp[3][5]`** 값이 **`true`**이면 문자열 **`s`**와 패턴 문자열 **`p`**가 일치하는 것으로 판단.

어우 따라가기만 해도 어질어질한 설명이다. 이해는 하겠는데 안보고 짤려면 정말 많이 공부해야겠다는 생각이 든다.

***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}