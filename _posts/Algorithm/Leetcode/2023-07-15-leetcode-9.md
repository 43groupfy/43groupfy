---
title:  "9. Palindrome Number"
excerpt: "9. Palindrome Number"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-07-15
last_modified_at: 2023-07-15
---
***
## Palindrome Number

  Integer 형의 변수 x 를 받아서 대칭인지 아닌지 확인하고, 대칭일 시 True, 대칭이 아닐 시 False를 반환하는 함수를 만드는 문제이다.

 x 의 범위는 

 `-231 <= x <= 231 - 1`

처음 생각한 방법은

1) Integer에서 String 형식으로 변환(std::to_string)해서 vector 자료형에 집어넣고(vector<string>),

2) iterator를 vector 양 끝에서 중앙으로 움직이면서,

iterator 끼리 교차되거나(문자 개수가 짝수),

iterator 가 한 곳에서 만날 때까지(문자 개수가 홀수),

인자들을 비교하는 것이었다. 

하지만….

**Follow up:** Could you solve it without converting the integer to a string?

나같이 생각한 사람이 얼마나 많았으면…

  그럼 integer 상태에서 대칭인지 알려면 어떻게 해야 할까?

NCS의 연산 문제처럼 대칭수의 각 수를 더해보거나,  빼보거나, 곱해보거나 해서 규칙을 찾아본 끝에,

대칭수의 경우에는 제곱을 한 값도 마찬가지로 대칭수가 나온다는 것이다

ex) 

11* 11 = 121

121*121 = 14641

우리가 하는 곱셈을 풀어서 생각해 보면 

(121*1)+(121*20)+(121*100) 로 볼 수 있는데 이는 자세히 생각해보면 컴퓨터의 곱셈의 원리(우 시프트 연산)과  비슷하다는 것을 알 수 있다.

ex) 

11 * 11 을 컴퓨터에서 산술하는 방법

=1011(2) * 1011(2)

= 1011(2) * 1(2) + 1011(2)*10(2) + 1011(2)*1000(2) 이 되겠다 

    

생각 나는 방법으로는

1. X의 자리값 계산
    
    ex) 2332 = 4자리
    
2. X %10의 (n-1) 값 의 몫 과 X % 10의 1 값의 나머지 비교(몫 저장할 것)!
    
    ex) 2332 / 1000 = 몫 : 2 , 나머지 = 332
    
    2332 / 10 = 몫 : 233 , 나머지 = 2 
    
3. X%10의 (n-2) 값과 X%10의 2값의 나머지 비교에서 
    
    ex) 2332 / 100 = 몫 : 23, 나머지 = 32 → 비교할 값 23 - (2*10) = 3
    
    2332 / 100 = 몫 : 23, 나머지 = 32 → 비교할 값 32 / 10 = 3
    
4. 총 n/2번 반복

아니면

1. 몫이 0이 될 때까지
2. X의 몫과 나머지를 계산하면서 나머지를 저장(나머지는 나눈 몫/10 값으로 나누기 ), 마지막에는 몫 값을 저장
    
    ex) 2332 /10 = 몫 : 233, 나머지 2 / 1 = 2
    
    2332 /100 = 몫 : 23, 나머지 32 → 나머지 32 / 10 = 3
    
    2332/1000 = 몫 : 2, 나머지 332 → 나머지 332 / 100 = 3 
    
    2332/10000 = 몫 : 0, 나머지 2332 → 종료
    
    ex) 10/10 = 몫 : 1, 나머지 0 → 나머지 0이면 그냥 넣어버리기
    
3. 결과 : [2, 3, 3, 2]

아니면 시프트 연산으로 밀면서 계산하던가…

결과

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0)
        {
            return false;
        }

        else if (x < 10)
        {
            return true;
        }
        else
        {
            int x_mod = 1;
            int x_divid = 1;
            int result = 0;
            std::vector<int> store_x_mod = {};
            for (; (pow(10,x_divid)) <= x; x_divid++)
            {
                result = x / pow(10, x_divid);
                x_mod = x % (int)(pow(10, x_divid));
                
                if (x_mod == 0)
                {
                    store_x_mod.push_back(x_mod);
                    continue;
                }
                x_mod = x_mod / pow(10,(x_divid-1));
                store_x_mod.push_back(x_mod);
            }
            store_x_mod.push_back(result);

            vector<int>::iterator iter_begin;
            vector<int>::iterator iter_end;
            iter_begin = store_x_mod.begin();
            iter_end = store_x_mod.end();
            for (; iter_begin < iter_end; iter_begin++)
            {
                if (*iter_begin == *(iter_end-1))
                {
                    iter_end--;
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
    }
};
```

### 결과

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ee8d58c-fadd-4cb2-92b0-1a1c74adb553/%EC%BA%A1%EC%B2%98.png)

## 가장 추천 많이 받은 풀이

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        stack<int> st;
        if(x<0)
            return false;
        int y=x;
        while(x)
        {
            st.push(x%10);
            x/=10;
        }
        while(y)
        {
            if(st.top()!=(y%10))
               return false;
             st.pop();
               y/=10;
        }
        return true;
    }
};
```
***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}