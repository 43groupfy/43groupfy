---
title:  "5. Longest Palindromic Substring"
excerpt: "5. Longest Palindromic Substring"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-06-05
last_modified_at: 2023-06-05
---
***
## **Longest Palindromic Substring**

Given a string `s`, return *the longest* *palindromic* *substring* in `s`.

**Example 1:**

```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

```

**Example 2:**

```
Input: s = "cbbd"
Output: "bb"

```

**Constraints:**

- `1 <= s.length <= 1000`
- `s` consist of only digits and English letters.

### 과정

1시간 동안 생각나는 게 다 대입해보는 Brute Force밖에 생각나지 않아서 결국 답지를 보고야 말았다.

보고나서야 이게 DP(Dynamic Programming) 문제라는 걸 깨달았다.

애초에 HIde Hint에서도

Complexity based hint:

If we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.

라고 전의 계산을 어떻게 활용해야할 것인가? 라고 적혀있기까지 했는데…

답지 풀이를 해보자
```cpp

class Solution 
{
private:
	bool isPalindrome(vector<vector<bool>>& dp, string& s, int l, int r) 
	{
	if(l==r)
		return dp[l][r] = true;
	else if(r-l==1)
		return dp[l][r] = s[l]==s[r];
	else
		return dp[l][r] = dp[l+1][r-1] ? s[l]==s[r] : false;
	}
public:
	string longestPalindrome(string s) 
	{
	int n=s.size(), startPos=0, maxLen = 0;
	vector<vector<bool>> dp(n, vector<bool>(n, false));
	for(int offset=0; offset<n; offset++) 
		{
		for(int i=0, j=offset; j<n; j++, i++){ // fixed offset sliding window
			if(isPalindrome(dp, s, i, j) && offset>=maxLen) 
			{
				// is a longer palindrome; can be also written as offset +1 > maxLen
				startPos = i;
				maxLen=offset+1;
			}
		}
	}
	return s.substr(startPos, maxLen);
}
```



};



***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}