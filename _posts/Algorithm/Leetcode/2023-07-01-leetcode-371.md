---
title:  "371. Sum of Two Integers"
excerpt: "371. Sum of Two Integers"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-07-01
last_modified_at: 2023-07-01
---
***
## Sum of Two Integer

 

### 1. 생각해보기

+, - 연산 없이 a+b의 값을 출력하라는 문제이다.

상당히…sense를 발휘해야만 할 것 같은 문제 같다

+, - 계산 부호 외에 값을 변경할 수 있는 방법은 무엇이 있을까?

(사실 제일 먼저 떠올랐던 건,  $a^2-b^2$ 였다. 하지만 -도 안되니깐 탈락)

1) *, -, ^, & 등등의 기타 부호

2) 비트 연산자

다른 부호를 사용해서 a+b를 내보려 해도 결국은 끝에는 + 를 써야 헀다.

결국 남은 건 비트 연산자 밖에 없으니 어떻게 해야 비트 연산자로 a+b를 계산할 수 있을지 생각해 보자

**비트 연산자**

| 연산자 | 의미 | 사용법 | 예제 | 설명 |
| --- | --- | --- | --- | --- |
| & | AND | x & y | x = 00000011 = 3y = 00000110 = 6x & y → 00000010 = 2 | 두 비트가 모두 1일 경우에만 1 |
| | | OR | x | y | x = 00000011 = 3y = 00000110 = 6x | y → 00000111 = 7 | 두 비트 중에서 하나라도 1이면 1 |
| ^ | XOR | x ^ y | x = 00000011 = 3y = 00000110 = 6x ^ y → 00000101 = 5(x ^ y) ^ y → 00000011 = 3 | 두 비트가 같으면 0, 다르면 1 |
| ~ | NOT | ~x | x = 00000010 = 2~x = 11111101 = 253 | 각 비트를 반전, 0이면 1, 1이면 0 |
| << | Left Shift | x << 2 | x = 00000001 = 1x << 2 = 00000100 = 4 | 비트를 왼쪽으로 이동 하나 이동할 때마다 곱하기 2 |
| >> | Right Shift | x >> 2 | x = 00000100 = 4x >> 2 = 00000001 = 1 | 비트를 오른쪽으로 이동 하나 이동할 때마다 나누기 2 |

4 와 7을 예로 들어보면,

4 = 00000100(2) = $2^2$

7 = 00000111(2) = $2^2+2+1$

에서 

11 = 0001011(2) = $2^3$ + $2+1$

을 만들어야 한다.

비트로 표현하니 눈에 잘 들어오게 되는데

1) XOR(^ 연산자)로 두 변수 간에 중복되지 않는 값을 구할 수 있을 것 같다

2) 중복되는 비트 위치는 AND(&)로 위치를 알 수 있다.

이를 쫒아가 보면

a = 4

b = 7

a^b = 3(00000011(2))

a&b = 4(00000100(2))

합 값을 위해서는 carry가 일어나야 하므로

a&b<<1 = 8 (00001000(2)

이 된다. 

여기서 벌써 $2^3$과 $2+1$ 을 얻었지만 +를 쓸 수는 없으니 한 개로 값을 몰아주는 방법을 생각해야 한다

즉, 중복되지 않는 값이 0이 될 때까지 XOR과 &후 <<를 반복한다.

a_1 = 3(00000011)

b_1 = 8(00001000)

a_1^b_1 = 11(00001011)

a_1&b_1 = 00000000  →&가 0이 되었으므로 중단

여기까지 하다보면 재귀적인 냄새(dp의 향기)가 난다는 것을 알 수 있는데,  바로 전의 연산으로 나온 값이 다음 연산에 그대로 쓰이므로 recursive하게 코드 작성이 가능할 것 같다.

- 멈추는 조건은?
    - 중복되지 않는 값(a&b)이 존재하지 않을 때

### 코드

```cpp
class Solution {
public:
int getSum(int a, int b) {
if(b==0) return a;
int sum = a^b;
int carry =(unsigned int)(a&b)<<1;
return getSum(sum,carry);
}
};
```

### 결과

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ba950fb3-2150-42f9-9c03-441edd65e8a4/%EC%BA%A1%EC%B2%98.png)
***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}