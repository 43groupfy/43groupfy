---
title:  "3. Longest substring Without Repeating Characters"
excerpt: "3. Longest substring Without Repeating Characterss"

categories:
    - Leetcode
tags:
    - [Leetcode]

toc: trueQ
toc_sticky: true
 
date: 2023-06-04
last_modified_at: 2023-06-04
---
***
## Longest substring Without Repeating Characters

Given a string s, find the length of the**longest substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

- `0 <= s.length <= 5 * 104`
- `s` consists of English letters, digits, symbols and spaces.

### 과정

문자열 내에 반복 문자가 아닌, 가장 긴 문자열을 찾는 문제이다.

생각한 과정은 문제 해결 과정 그 대로 따라가는 방식이었다.

1. 문자를 하나하나 넣을 string와 길이를 저장할 vector를 생성
2. 문자를 만날 때마다,
    1. 현재까지 저장한 문자열 내에서 같은 문자가 있는 지 찾기(string.find())
        1. 있으면, 이 때까지의 길이를 vector에 넣고, 찾은 문자열 앞에서 다시 시작
        2. 없으면, 임시 string에 문자를 추가하기
3. 문자 전체 길이까지 순회가 끝나면, 길이들을 저장해둔 vector에서 가장 큰 길이 값을 찾아서 return

가 되겠다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {

      vector<int> dup_v ={0};
      string::iterator s_start = s.begin();
      string::iterator s_end = s.begin();
      int sector_dist =0;
      string temp_s="";
      for(;s_end != s.end();s_end++)
      {
          if(temp_s.find(*s_end)!= string::npos)
          {
            sector_dist = distance(s_start, s_end);
            sector_dist = sector_dist==0?1:sector_dist;            
            dup_v.push_back(sector_dist);
            s_start++;  
            s_end =s_start;  
            temp_s =*s_start; 
          }
          else
          {
            temp_s.push_back(*s_end);            
          }
      };  
      dup_v.push_back(temp_s.size());
      sort(dup_v.rbegin(),dup_v.rend()); 
          return dup_v[0];            
    }
};
```

sort에, 찾으면 다시 돌아가기까지 하니 개판이다.

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/11bff575-9c6e-424c-9b99-b67e03ff708d/%EC%BA%A1%EC%B2%98.png)

## 가장 추천 많이 받은 풀이

https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists/

및 다양한 풀이 방법

https://www.geeksforgeeks.org/length-of-the-longest-substring-without-repeating-characters/

밑의 분이 sliding window 알고리즘에 대해 엄청 잘 해석해준다.

https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/?orderBy=most_votes

정말 다양한 해결 방식이 쏟아져 나온다.

대표적인 것 몇 개를 공부해보자

1. Sliding Window Algorithm

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.length()==0)return 0;   //if string of length zero comes simply return 0
        unordered_map<char,int> m;   //create map to store frequency,(get to know all unique characters
        int i=0,j=0,ans=INT_MIN; 
        while(j<s.length())   
        {
            m[s[j]]++;  //increase the frequency of the element as you traverse the string
            if(m.size()==j-i+1)  // whem map size is equal to the window size means suppose window size is 3 and map size is also three that means in map all unique characters are their
            {
                ans = max(ans,j-i+1);  //compare the length of the maximum window size
            }
            else if(m.size()<j-i+1)   //if the map size is less than the window size means there is some duplicate present like window size = 3 and map size = 2 means there is a duplicates
            {
                while(m.size()<j-i+1)  //so till the duplicates are removed completely
                {
                    m[s[i]]--;   //remove the duplicates
                    if(m[s[i]]==0)  //if the frequency becomes zero 
                    {
                        m.erase(s[i]);//delete it completely
                    }
                    i++;  //go for next element 
                }
            }
             j++;  //go for the next element
        }
        return ans;
    }
};
```

Sliding Window 의 핵심은 hash map을 사용해서 이전 인덱스를 저장해 놓는 것이다.

1. 해시 맵을 사용해서 입력 문자열에서 각 문자의 마지막으로 본 인덱스를 추적하기
2. 

```cpp
int lengthOfLongestSubstring(string s) {
unordered_map<char, int> char_map;
int max_length = 0;
int start = 0;
for (int i = 0; i < s.size(); i++) {
if (char_map.count(s[i]) && char_map[s[i]] >= start) {
max_length = max(max_length, i - start);
start = char_map[s[i]] + 1;
}
char_map[s[i]] = i;
}
return max(max_length, (int)s.size() - start);
}
```

1. KMP 알고리즘을 적용한 방식
```cpp
using namespace std;
 
int longestSubstrDistinctChars(string s)
{
    if (s.length() == 0)
        return 0;
    int n = s.length();
    set<char> st;
    int len = 1;
    st.insert(s[0]);
    int i = 1;
    int maxLen = 0;
    while (i < n)
    {
        if (s[i] != s[i - 1] && st.find(s[i]) == st.end())
        {
            st.insert(s[i]);
            len++;
            i++;
            if (len > maxLen)
            {
                maxLen = len;
            }
        }
        else
        {
            if (len == 1)
            {
                i++;
            }
            else
            {
                st.clear();
                i = i - len + 1;
                len = 0;
            }
        }
    }
    return max(maxLen, len);
}
```
***
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}