---
title: "[C++] BOJ 11657 타임머신"
excerpt: "BOJ 11657 타임머신에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-06
last_modified_at: 2022-02-06
mainfont: Bareun_hipi
---

# [C++] BOJ 11657 타임머신

## 문제

[BOJ 11657 타임머신](https://www.acmicpc.net/problem/11657)

## 풀이

벨만-포드의 대표 문제이다.

## 코드

```c++
#include <cstdio>
#include <queue>
#define INF 999999999
using namespace std;
typedef long long ll;
struct info{int e; ll t;};
int n, m;
ll dis[501];
vector<info> graph[501];

int bellmanford() {
    dis[0] = 0;
    for(int i = 0; i < n; i++) { // 정점의 수 만큼 반복
        for(int cur = 0; cur < n; cur++) {
            if (dis[cur] == INF) continue; // 현재 갱신되지 않았던거라면, 32번째 줄이 의미가 없음
            for(int j = 0; j < graph[cur].size(); j++) {
                int nxt = graph[cur][j].e;
                ll cost = graph[cur][j].t;
                if (dis[nxt] > dis[cur] + cost) {
                    dis[nxt] = dis[cur] + cost;
                    if (i == n-1) return 0; // N번째에서도 갱신이 된다면 음수 간선 순환이 발생하는 것이므로 0을 return
                }
            }
        }
    }
    return 1;
}

int main() {
    scanf("%d %d", &n, &m);
    int a,b; ll c;
    for(int i = 0; i < n; i++) dis[i] = INF;
    for(int i = 0; i < m; i++) {
        scanf("%d %d %lld", &a, &b, &c);
        a--, b--;
        graph[a].push_back({b,c});
    }
    if (!bellmanford()) printf("-1");
    else {
        for(int i = 1; i < n; i++) {
            if (dis[i] == INF) printf("-1\n");
            else printf("%lld\n", dis[i]);
        }
    }
}
```
