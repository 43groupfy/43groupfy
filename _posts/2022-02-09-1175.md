---
title: "[C++] BOJ 1175 배달"
excerpt: "BOJ 1175 배달에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-09
last_modified_at: 2022-02-09
mainfont: Bareun_hipi
---

# [C++] BOJ 1175 배달

## 문제

[BOJ 1175 배달](https://www.acmicpc.net/problem/1175)

## 풀이

BFS문제이다.

한 지점에 대해 두번 이상 방문이 가능하므로 단순히 `vis[행][열]`으로 방문여부를 판단해서는 안된다.

이전에 어떤 방향이었는지와 배달해야 할 지점에 대한 방문 여부를 추가하여 `dis[행][열][이전에 이동한 방향][배달 지점 방문 여부]`로 설정해주었다.
여기서 배달해야 할 지점에 대한 방문 여부는 비트마스킹을 사용하여

1. 00 : 아무 곳도 방문하지 않음
2. 01 : 첫번째 배달 장소만 방문함
3. 10 : 두번째 배달 장소만 방문함
4. 11 : 모두 방문 함

로 설정했다.

따라서 queue의 원소들도 info라는 구조체를 만들어 주어 필요한 값들을 넣어주었다. 추가로 cnt는 방문 시간(횟수)를 의미한다.

## 코드

```c++
#include <cstdio>
#include <queue>
using namespace std;
int dy[] = {0, 1, 0, -1}, dx[] = {-1, 0, 1, 0};
struct axis { int x, y; };
struct info {
    int x, y, pre, del, cnt;
};
int n, m;
axis s, e1 = {-1, }, e2;
char arr[50][50];
int vis[50][50][4][4];

int go() {
    queue<info> q;
    for(int i = 0 ; i < 4; i++) q.push({s.x, s.y, i, 0, 0});

    while (!q.empty()) {
        info t = q.front(); q.pop();
        if ((t.del & (1<<0)) and (t.del & (1<<1))) return t.cnt;

        for(int i = 0; i < 4; i++) {
            int bt = t.del;
            if (t.pre == i) continue;
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 or y < 0 or x >= n or y >= m) continue;
            if (arr[x][y] == '#') continue;
            if (x == e1.x and y == e1.y) bt |= (1<<0);
            else if (x == e2.x and y == e2.y) bt |= (1<<1);
            if (vis[x][y][i][bt]) continue;
            vis[x][y][i][bt] = 1;
            q.push({x, y, i, bt, t.cnt + 1});
        }
    }
    return -1;
}

int main() {
    scanf("%d %d", &n, &m);
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            scanf(" %c", &arr[i][j]);
            if (arr[i][j] == 'S') s = {i, j};
            else if (arr[i][j] == 'C' and e1.x == -1) e1 = {i, j};
            else if (arr[i][j] == 'C') e2 = {i, j};
        }
    }
    printf("%d", go());
}
```
