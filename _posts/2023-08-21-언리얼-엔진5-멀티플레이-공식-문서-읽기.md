---
title: 언리얼 엔진 5 멀티플레이 공식 문서 읽기
layout: post
author: littley
date: 2023-08-21 00:00:00 +0900
categories: [UnrealEngine, Multiplay]
tags: [UE5]
toc: true
toc_sticky: true
---

## 언리얼 멀티플레이 서버

언리얼 멀티는 **클라이언트-서버** 모델을 사용한다. 한 서버가 게임의 **호스트** 역할을 하고 호스트에 연결된 플레이어는 **클라이언트** 역할을 한다. 실제 게임 스테이트는 서버에서 조정하며, 이 때 서버를 **권한 있는 호스트(authoritative host)** 라고 한다. 플레이어는 **자율 프록시(autonomous proxy)**로 폰을 제어한다. 서버는 연결된 각 클라이언트의 변경사항을 **리플리케이트(replicate)** 해서 연결된 각 클라이언트의 실제 게임 스테이트를 시뮬레이션 한다. 이때, 클라이언트는 서버에서 실제로 플레이되고 있는 게임에 아주 가까운 근사값을 보게 된다.

### 리슨 서버와 데디케이티드 서버

**리슨 서버**는 자신의 머신에서 게임을 호스팅하면서 서버 역할을 하는 클라이언트다. 다른 클라이언트들은  이 클라이언트의 인스턴스에서 게임을 플레이한다. 호스팅하는 클라이언트(즉 리슨 서버)가 권한 있는 호스트가 된다. 

반면 **데디케이티스 서버(dedicated server)는** 헤드리스, 즉 플레이하는 클라이언트가 없는 형태로 구성된다. 각 플레이어는 원격 클라이언트로 참여한다. DS 서버는 비주얼을 렌더링하지 않고, 로컬 플레이어가 존재하지 않는다.

후자의 경우 여러 장점을 갖는데,

- 더 작은 규모
- 호스트 클라이언트에게만 주어지는 이점이 없음
- 서버가 게임플레이 로직 및 클라이언트로부터 받는 정보를 조정하는 데 집중할 수 있음

전자는 캐주얼 멀티플레이어 및 협동 게임에 적합하고, 후자는 대규모 혹은 경쟁 게임에 적합하다.

### 서버 게임플레이 흐름

게임플레이 상태와 흐름은 일반적으로 `GameMode` 액터를 통해 구동된다. 서버에만 이 액터의 유효 사본이 저장된다(클라에는 X). 

이 상태를 클라이언트에게 알리는 액터는 `GameState`이다. `GameState`는 각 클라이언트에게 리플리케이트 되도록 마킹되어 있다. 클라이언트는 이 `GameState` 액터에 대한 사본을 추정하여 저장하고, 사본을 토대로 게임의 일반적인 상태를 안다. 

---

## 리플리케이션

리플리케이션의 주역은 액터다. 서버는 액터 목록을 유지하고, 클라이언트들이 각 엑터에 대한 추정치를 유지할 수 있도록 주기적인 업데이트를 한다. 액터의 업데이트 방식은 다음 두 가지다.

- 프로퍼티 업데이트(`UPROPERTY`를 이용한 리플리케이트)
- **RPC(Remote Procedure Call)**

둘의 가장 큰 차이점은 전자는 **변경될 때 마다 자동으로 리플리케이트**되는 반면, 후자는 **실행될 때만 리플리케이트** 된다는 것이다. 전자의 주요 예시로는 자주 변화하는 요소인 체력을 들 수 있고, 후자의 경우에는 특정 위치에서만 호출되는 이펙트 등이 있다.

### 프로퍼티 리플리케이션

각 액터에는 `Replicated` 지정자를 포함하는 모든 프로퍼티 목록이 유지된다. 서버는 리플리케이트된 프로퍼티의 값이 변할 때마다 각 클라이언트에 업데이트를 전송하고, 클라이언트는 이를 액터의 로컬 버전에 적용한다. 클라이언트는 프로퍼티 업데이트를 서버나 다른 클라이언트로 절대 전송하지 않는다.

> 💡 클라이언트에서 리플리케이트된 변수의 값을 바꾸는 것은 비추천이다. 다음에 서버가 변화를 감지하고 업데이트를 전송할 때 까지 서버의 값과 클라이언트의 값이 달라지기 때문이다.

프로퍼티 리플리케이션은 **신뢰성**이 중요하다. 클라이언트의 액터 프로퍼티 값은 서버의 값을 항상 반영한다는 의미지만, 클라이언트가 서버에 있는 프로퍼티의 **개별 변경사항에 대한 모든 알림**을 받지는 못할 수도 있다.

즉 특정한 정수 프로퍼티가 서버에서 100, 200, 300 순으로 매우 빠르게 변경되었다면, 최종적으로 클라이언트 프로퍼티에서도 값이 300으로 업데이트 되겠지만 **중간에 200이었음을 안다는 보장은 없다.**

### 예시 코드

프로퍼티가 정의되는 액터의 헤더에서 `UPROPERTY` 선언에 `replicated` 키워드를 넣어주어야 한다.

```cpp
class ENGINE_API AActor : public UObject
{
    UPROPERTY( replicated )
    AActor * Owner;
};
```

또한 액터 클래스의 구현에서 `GetLifetimeReplicatedProps` 함수를 구현해주어야 한다.

```cpp
void AActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    DOREPLIFETIME( AActor, Owner );
}
```

액터의 생성자에서 플래그 설정이 올바르게 되어 있는지 확인한다.

```cpp
AActor::AActor(const class FPostConstructInitializeProperties& PCIP) : Super(PCIP)
{
    bReplicates = true;
}
```

### 네트워크 업데이트 최적화

액터의 `NetUpdateFrequency` 변수 설정을 통해 업데이트 빈도를 바꿀 수 있다. 이 방법에는 **데이터 주도형 네트워크 업데이트 빈도, 적응형 네트워크 업데이트 빈도** 두가지 방식이 있다.

- 데이터 주도형 네트워크 업데이트
    
  슈팅 게임에서 플레이어가 조종하는 액터처럼 중요하고 예측 불가능한 경우 10(0.1초마다 업데이트), 
  협력 게임에서 AI 조종 몬스터처럼 조금 느리게 움직이는 캐릭터의 경우 5(0.2초마다 업데이트), 
  중요하지는 않지만 네트워크를 통해 동기화를 해야 하거나 서버측 로직의 조종을 받아 리플리케이션이 필요한 경우는 2(0.5초마다 업데이트) 정도로 설정한다.
    
- 적응형 네트워크 업데이트
    
  기본적으로 비활성화 되어있어, 콘솔 변수 `net.UseAdaptiveNetUpdateFrequency`를 1로 설정하면 활성화된다.
  
  이 기능을 켜면 업데이트가 유의미한지에 따라 개별 액터의 업데이트 빈도를 시스템이 동적으로 적응시킨다. ‘유의미하다’는 말은 액터의 초기화, 액터에 서브오브젝트 추가 또는 제거, 액터 혹은 그 서브오브젝트의 리플리케이티드 프로퍼티 값을 변경하거나 하는 업데이트를 말한다. 
  
  각 액터에 가능한 업데이트 비율 범위는 액터 자체의 변수 둘로 결정된다. 하나는 액터가 초당 최대 몇번까지 업데이트를 시도할지 결정하는 `NetUpdateFrequency`, 다른 하나는 초당 최소 몇번까지 업데이트를 시도할지 결정하는 `MinNetUpdateFrequency`이다.
  

## RPC(Remote Procedure Call)

RPC는 로컬에서 호출되지만 이 로컬과 연결되어 있는 원격에서 실행되는 함수를 말한다. 주로 연결된 상대에게 원하는 프로퍼티를 즉각적으로 업데이트하도록 요청할 때 사용한다.

RPC를 사용하려면 함수를 선언할 때 키워드를 추가해주기만 하면 된다. 

```cpp
// 서버에서 호출되지만 클라이언트에서 실행되는 RPC 함수 선언
UFUNCTION( Client )
void ServerRPCFuction();

// 클라이언트에서 호출되지만 서버에서 실행되는 RPC 함수 선언
UFUNCTION( Server )
void ServerRPCFunction();

// 서버에서 호출한 후 서버 및 모든 연결된 클라이언트에서 실행되는 RPC 함수
UFUNCTION( NetMulticast )
void MulticastRPCFunction();
```

### RPC 작동 요건 및 주의사항
RPC의 정상 작동을 위해서는 몇가지 요건을 충족해야 한다.
1. 리플리케이트되는 `Actor`에서 호출될 것.
2. 서버에서 호출되고 클라이언트에서 실행되는 `RPC`의 경우 해당 액터를 실제로 소유하고 있는 클라이언트에서만 함수가 실행됨.
3. 클라이언트에서 호출되고 서버에서 실행되는 `RPC`의 경우 클라이언트가 해당 액터를 소유하고 있어야 함.
4. `Multicast RPC`는 예외:
  - 서버에서 호출하면 서버의 로컬 및 연결된 모든 클라이언트에서도 실행됨.
  - 클라에서 호출하면 로컬에서만 실행되고, 서버에서는 실행되지 않음

또한 기본적으로 RPC는 비신뢰성이기 때문에(UDP 방식), 원격에서 확실히 실행되게 하려면 `Reliable` 키워드를 붙여야 한다.
```cpp
UFUNCTION( Client, Reliable )
void ClientRPCFunction();
```


# 참고

[[UE5 문서] 전용 서버 구성하기](https://docs.unrealengine.com/5.2/ko/setting-up-dedicated-servers-in-unreal-engine/)

[[UE5 문서] 액터와 그 접속 소유](https://docs.unrealengine.com/5.2/ko/actors-and-their-owning-connections-in-unreal-engine/)

[[UE4 문서] 클라이언트-서버 모델](https://docs.unrealengine.com/4.26/ko/InteractiveExperiences/Networking/Server/)

[[UE4 문서] 액터 리플리케이션](https://docs.unrealengine.com/4.26/ko/InteractiveExperiences/Networking/Actors/)

[[Tistory] 네트워킹과 멀티플레이어](https://noooong1231.tistory.com/97)