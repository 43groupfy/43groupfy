---
title: "[C++] BOJ 1865 웜홀"
excerpt: "BOJ 1865 웜홀에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-07
last_modified_at: 2022-02-07
mainfont: Bareun_hipi
---

# [C++] BOJ 1865 웜홀

## 문제

[BOJ 1865 웜홀](https://www.acmicpc.net/problem/1865)

## 풀이

한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지를 판단하는 문제이다. 이 말은 곧 **임의의 음의 순환이 있는지**를 물어보는 문제이다.

처음에 나는 `reset()`에서 `dis[i]`을 INF(= 1e9)로 초기화를 해주고 벨만-포드(`go()`)를 돌릴 때 시작노드의 `dis`를 0으로 초기화를 해주었는데 틀렸습니다가 나왔다.
그 이유는 문제에서는 출발지점을 지정해주지 않고 '한' 지점이라고만 하였기 때문이다.
곧, 내가 `dis[0]`만 0으로 해주고 나머지를 INF로 초기화했다는 말은 0의 노드에서 출발했을 때에 해당되는 말인거다. 만약, 0번노드에서 시작했을 때 음의 순환을 갈 수 없을 경우엔? 당연히 틀린 풀이가 되는 것이다.

모든 정점에서 동시에 시작을 해 주기 위해 `reset()`에서 `dis[i]`를 0으로 초기화를 해주었다.

## 코드

```c++
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int, int> pii;

int tc, n, m, w;
int s, e, t;
vector<pii> graph[500];
int dis[500];

int go() {
    dis[0] = 0;
    for(int i = 0; i < n; i++) { // 모든 정점에 대해 살펴본다.
        for(int cur = 0; cur < n; cur++) {
            for(int j = 0; j < graph[cur].size(); j++) {
                int nxt = graph[cur][j].first;
                int cost = graph[cur][j].second;
                if (dis[nxt] > dis[cur] + cost) { // 만약 cur정점을 거쳐서 nxt정점에 도달하는 것이 더 적다면 갱신시켜 준다.
                    dis[nxt] = dis[cur] + cost;
                    if (i == n-1) return 1; // N번째도 갱신이 됐다면 음의 순환이 있다는 뜻
                }
            }
        }
    }
    return 0;
}

void reset() {
    for(int i = 0; i < n; i++) {
        graph[i].clear();
        dis[i] = 0; // dis[i]를 0으로 초기화해준다.
    }
}

int main() {
    scanf("%d", &tc);
    while (tc--) {
        scanf("%d %d %d", &n, &m, &w);
        reset();
        for(int i = 0; i < m; i++) {
            scanf("%d %d %d", &s, &e, &t);
            s--; e--;
            graph[s].push_back({e, t});
            graph[e].push_back({s, t});
        }
        for(int i = 0; i < w; i++) {
            scanf("%d %d %d", &s, &e, &t);
            s--; e--;
            graph[s].push_back({e, t*(-1)});
        }
        if (go()) printf("YES\n");
        else printf("NO\n");
    }
}
```
