---
title: Link Layer
date: 2022-07-15-15:38 +0900
categories: [Study, Computer Network]
tags: [Link Layer]
---

## 링크 계층 소개
<hr style="border-top: 1px solid;"><br>

링크 계층에서는 데이터그램을 출발지 호스트 노드에서 목적지 호스트 노드까지 전달하기 위해선 개별 링크로 데이터그램을 이동시켜야 한다.

한 링크에서 전송 노드는 데이터그램을 링크 계층 프레임으로 캡슐화해서 링크로 전송한다. 

<br><br>

### 링크 계층이 제공하는 서비스
<hr style="border-top: 1px solid;"><br>

기본 제공 서비스는 데이터그램을 이동시키는 것이고 세부적으로는 아래와 같다.

+ 프레임화

+ 링크 접속 
  + 매체 접속 제어 (Media Access Control, MAC) 프로토콜은 링크상으로 프레임을 **전송**하는 **규칙**에 대해 명시한다.

+ 신뢰적 전달
  + 재전송과 확인응답 기능을 통해 가능하며 주로 오류율이 높은 무선 링크에서 서비스를 제공한다.
  + 오류가 발생하면 종단간에 재전송을 하는 것이 아니라 오류가 발생한 링크에서 오류를 정정한다.
  + 오류율이 낮은 유선 링크(광섬유, 동축케이블 등)에서는 불필요한 오버헤드가 발생하므로 제공하지 않는다. 

+ 오류 검출과 정정
  + 링크계층에서 일반적으로 제공하는 서비스이며, 프레임에 오류 검출 비트를 통해 오류를 검출하고 정정하는 과정은 프레임에 오류가 발생한 곳을 정확하게 찾아 정정한다.

<br><br>

### 링크 계층이 구현되는 위치
<hr style="border-top: 1px solid;"><br>

일반적으로 네트워크 인터페이스 카드(NIC)로 알려진 네트워크 어댑터에 구현된다.

어댑터 중심에는 링크 계층 제어기가 있으며, 제어기는 링크 계층 서비스가 구현되어 있는 특수 용도 칩이다.

따라서 링크 계층 제어기의 기능 대부분은 하드웨어로 구현된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/180366766-70ce164d-76d4-4819-9bc6-52b3a8d464c0.png)

<br>

송신 측 제어기는 데이터그램을 프레임화하고 링크 접속 프로토콜에 따라 링크상으로 전송한다.

수신 측 제어기는 프레임을 수신한 후 네트워크 계층 데이터그램을 추출한다.

링크 계층에서 오류를 검출하는 경우, 송신 측 제어기는 프레임 헤더의 오류 검출 비트를 설정하고 수신 측 제어기는 오류 검출을 수행한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 스위치 근거리 네트워크
<hr style="border-top: 1px solid;"><br>

![image](https://user-images.githubusercontent.com/52172169/180367449-b7c5b903-288a-4ad2-b76b-027782fbe613.png)

<br>

위의 사진에서 4개의 스위치가 2개의 서버와 1개의 라우터, 세 학과를 연결하고 있다.

스위치는 **링크 계층**에서 동작하기 떄문에 프레임을 교환하고, 네트워크 계층 주소를 인식하지 않으며, 라우팅 알고리즘을 사용하지 않는다.

스위치 네트워크에서는 프레임 전달을 위해 IP 주소가 아닌 **링크 계층 주소**를 사용한다.

<br><br>

### 링크 계층 주소체계와 ARP
<hr style="border-top: 1px solid;"><br>

호스트와 라우터들은 링크 계층 주소를 가지는데, 호스트와 라우터는 네트워크 계층 주소도 가지고 있다.

이번에 왜 두 주소가 모두 필요한지와 IP주소를 링크 계층 주소로 변환하는 ARP(Address Resolution Protocol)에 대해 알아본다.

<br><br>

#### MAC 주소
<hr style="border-top: 1px solid;"><br>

링크 계층 주소를 가지고 있는건 NIC이다.

NIC가 여러 개면 링크 계층 주소로 여러 개 갖게 된다.

이 주소를 MAC주소(또는 랜 주소)라고 하고 길이는 6바이트이며, 따라서 2^48개만큼의 사용 가능한 랜 주소가 있다.

<br>

![image](https://user-images.githubusercontent.com/52172169/180368982-91dcdc2f-b225-4373-934c-2ece7b914238.png)

<br>

6바이트 주소는 16진수로 표현되고, 주소의 각 바이트는 2개의 16진수로 표시된다.

MAC주소는 고유의 주소를 가지고 있는데 이 부분은 IEEE가 MAC주소 공간을 관리하기 때문이다.

어떤 회사에서 어댑터를 제조하면 2^24개의 주소로 이루어진 주소 영역을 구매해야 한다.

IEEE에서는 MAC주소의 첫 24비트를 고정하고, 나머지 24비트는 회사로 하여금 각 어댑터에게 유일하게 부여하는 방식으로 2^24개 주소를 할당한다.

<br>

송신 어댑터가 프레임을 목적지 어댑터로 전송할 때, 프레임에 목적지 어댑터의 MAC 주소를 넣고 그 프레임을 랜상으로 전송한다.

스위치는 종종 프레임을 자신의 모든 인터페이스로 브로드캐스트한다.

따라서 어댑터는 자신을 목적지로 하지 않는 프레임도 수신할 수 있으며, 수신한 뒤 MAC 주소를 확인하여 목적지 MAC주소가 자신의 MAC주소라면 데이터그램을 추출하고 아니라면 폐기한다.

<br>

만약 송신 어댑터가 랜상의 모든 어댑터가 자신이 전송한 프레임을 수신하기를 원한다면 프레임 목적지 주소에 MAC 브로드캐스트 주소 (FF-FF-FF-FF-FF-FF)를 넣는다.

<br><br>

#### ARP
<hr style="border-top: 1px solid;"><br>

ARP는 IP주소와 MAC주소간의 변환을 담당하는 프로토콜이다.

ARP는 호스트네임을 도매인 네임으로 변환해주는 DNS와 비슷하나, ARP는 동일한 서브넷상의 호스트와 라우터의 IP 주소만을 해결한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/180371928-f702dd84-577c-49a5-afc7-4c2467e64763.png)

<br>

ARP에는 ARP 테이블이 있으며 여기에 각각의 IP에 대한 MAC주소 매핑이 등록되어 있다.

ARP 테이블에는 서브넷상의 모든 호스트와 라우터에 대한 엔트리를 갖지 않아도 된다.

즉, 어떤 노드는 등록되어 있지 않을 수 있고, 종료된 엔트리를 갖고 있을 수도 있다.

일반적인 엔트리 종료 시간은 등록된 후 20분이다.

<br>

만약 송신 노드의 ARP 테이블에 목적지 IP 엔트리가 등록되어 있지 않은 경우에는 어떻게 하는가?

이 경우 ARP 프로토콜을 사용한다.

송신 노드는 ARP 패킷을 구성하는데, 이 패킷에는 송신 및 수신 IP 주소와 MAC 주소를 포함하는 필드를 갖고 있다.

ARP 질의 패킷과 응답 패킷 모두 같은 형식을 가지며, ARP 질의 패킷의 목적은 해결하려는 IP 주소에 대응되는 MAC 주소를 결정하기 위해 **서브넷의 다른 모든 호스트와 라우터들에게 질의하는 것이다.(브로드캐스팅)**

수신 노드는 응답 ARP 패킷을 송신 노드에게 돌려보내고, 송신 노드는 자신의 ARP 테이블을 갱신한다.

<br>

ARP 프로토콜은 네트워크 계층 프로토콜이며 링크 계층 프로토콜이기도 하다.

<br><br>

#### 서브넷에 없는 노드로의 데이터그램 전송
<hr style="border-top: 1px solid;"><br>

![image](https://user-images.githubusercontent.com/52172169/180373335-8623566f-54ac-4822-ba6e-cba4e01a1b3c.png)

<br>

왼쪽 서브넷에서 오른쪽 서브넷으로 데이터그램을 전달한다고 가정한다.

그럼 왼쪽 서브넷 노드에서 목적지 MAC 주소를 설정해야 하는데 이 때, 목적지 MAC 주소는 오른쪽 서브넷 노드가 아니라 라우터 인터페이스 ```111.111.111.110```으로 설정해야 한다.

이 MAC 주소는 ARP 프로토콜을 이용해 구하면 된다. (같은 서브넷이므로 가능하다.)

송신 어댑터가 이 주소를 얻으면 프레임(목적지가 오른쪽 서브넷 노드인 데이터그램 포함)을 만들어 라우터로 전달하면, 왼쪽 서브넷 쪽에 있는 라우터의 어댑터는 프레임이 자신을 목적지로 하는지 검사한 후, 네트워크 계층으로 전달한다.

이제 데이터그램을 오른쪽 서브넷 노드로 전달해야 하는데, 라우터는 데이터그램이 전달될 정확한 인터페이스를 결정해야 한다.

이것은 라우터의 포워딩 테이블을 참조하면 가능하며, 목적지 MAC 주소 역시 ARP 프로토콜을 이용해 구할 수 있다.

따라서 라우터는 데이터그램을 자신의 어댑터로 전달하여, 프레임화한 후 실제 최종 목적지로 전달한다.

<br><br>

### 이더넷
<hr style="border-top: 1px solid;"><br>

인터넷이 글로벌 네트워킹에 대한 것이라면, 이더넷은 근거리 네트워킹에 관한 것이다.

우선은 스위치가 충돌 없는 장치일 뿐만 아니라 저장 후 전달 패킷 스위치라는 정도로만 이해하도록 한다.

스위치는 3계층까지 동작하는 라우터와 달리 2계층까지만 동작한다.

<br><br>

#### 이더넷 프레임 구조
<hr style="border-top: 1px solid;"><br>

![image](https://user-images.githubusercontent.com/52172169/180378414-fadea3fb-3067-4ae4-a7e9-52d9ac8dbe55.png)

<br>

+ 데이터
  + IP 데이터그램을 운반하고, 최대 전송 단위(MTU)는 1500바이트이고 최소 크기는 46바이트이다.
    + 즉, IP 데이터그램이 1500바이트를 초과하면 호스트가 이 데이터그램을 단편화해야 한다.
    + 반대로 46바이트보다 작으면 임의로 채워서 46바이트로 만들어야 한다. 

+ 목적지 주소(6바이트)

+ 출발지 주소(6바이트)

+ 타입 필드(2바이트)
  + 이더넷이 네트워크 계층 프로토콜을 다중화하도록 허용한다.
  + 호스트는 IP 프로토콜 이외의 다른 네트워크 계층 프로토콜(ARP 프로토콜)을 사용할 수 있으며 각각의 프로토콜은 자신만의 표준 타입 번호를 갖고 있다.

+ 순환중복검사(CRC)
  + 오류가 발생했는지 검출하는 필드

+ 프리앰블(8바이트)
  + 첫 7바이트는 10101010 값을 가지고 마지막 바이트는 10101011이다.
  + 첫 7바이트는 수신 어댑터를 깨우고 수신자의 클록을 송신자의 클록에 동기화시키는 역할을 한다.

<br><br>

#### 이더넷 기술
<hr style="border-top: 1px solid;"><br>

모든 이더넷 기술은 네트워크 계층에게 **비연결형 서비스**를 제공하고, **비신뢰적 서비스**를 제공한다.

예를 들면, 어댑터 A가 데이터그램을 어댑터 B로 전달한다고 가정한다.

어댑터 A는 먼저 어댑터 B와 핸드셰이킹하지 않고 이더넷 프레임에 데이터그램을 캡슐화해서 그 프레임을 랜으로 전송한다. (비연결형)

또한 만약 어댑터 B가 CRC를 통해 프레임을 검사하지만, 프레임이 CRC 검사를 통과해도 응답을 보내지 않고, 검사가 실패하면 어댑터 B는 프레임을 폐기하지만, NAK를 보내주지 않는다.

그래서 어댑터 A는 CRC 검사를 통과했는지에 대한 여부를 알 수 없다.

이러한 점이 이더넷을 단순하고 저렴하게 만들었다.

<br>

그럼 패킷이 손실되면 어떻게 프레임을 재전송하는가에 대해서는 애플리케이션이 TCP 또는 UDP를 사용하는지에 달려있다.

UDP를 사용한다면 그대로 패킷이 손실되는 것이고, TCP를 사용한다면 재전송을 통해 보장받을 것이다.

<br><br>

### 링크 계층 스위치
<hr style="border-top: 1px solid;"><br>

호스트/라우터는 중간에 스위치가 프레임을 받아서 다른 노드에게 전달하는 것을 알지 못한다.

프레임이 스위치 출력 인터페이스들 중 하나에 도착하는 속도가 그 인터페이스의 링크 용량을 일시적으로 초과할 수 있는데, 이를 해결하기 위해 스위치에도 버퍼를 만들었다.

<br><br>

#### 전달 및 여과
<hr style="border-top: 1px solid;"><br>

여과(filtering)는 프레임을 인터페이스로 전달할지 또는 폐기(drop)할지 결정하는 스위치 기능이다.

전달(forwarding)은 프레임이 전송될 인터페이스를 결정하고 프레임을 해당 인터페이스로 내보내는 기능이다.

스위치 여과와 전달은 스위치 테이블을 이용한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/180384951-ae4eae7d-7fbe-49bb-b51d-41c34e791d79.png)

<br>

스위치 테이블에는 MAC주소, MAC주소로 가게 하는 스위치 인터페이스, 해당 엔트리가 만들어진 시점에 대한 정보가 들어 있다.

스위치 여과와 전달 기능에 대한 예시를 보면, 목적지 주소 ```DD-DD-DD-DD-DD-DD```를 가진 프레임이 스위치의 인터페이스 x에 도착했다고 가정한다.

스위치는 자신의 테이블에서 MAC주소를 살펴보는데, 3가지 경우가 있다.

<br>

+ 해당 MAC주소 엔트리가 없는 경우
  + 스위치는 프레임의 복사본을 인터페이스 x를 제외한 모든 인터페이스의 앞에 있는 출력 버퍼로 전달(브로드캐스트)한다.  

+ 인터페이스 x와 연관된 엔트리가 있는 경우
  + 다른 인터페이스로 전달할 필요가 없으며, 프레임을 제거함으로써 여과 기능을 수행한다.

+ 해당 MAC주소가 인터페이스 y와 연관된 엔트리가 있는 경우
  + 인터페이스 y앞에 있는 출력 버퍼에 프레임을 넣음으로써 전달 기능을 수행한다.

<br><br>

#### 자가학습
<hr style="border-top: 1px solid;"><br>

스위치는 자신의 테이블을 자동으로 구축한다. 즉, 자가학습을 한다.

자가학습은 아래와 같이 이루어 진다.

1. 스위치 테이블은 초기에 비어 있다.

2. 인터페이스로 수신한 각 프레임에 대해 스위치는 ```1) 프레임의 출발지 주소 필드에 있는 MAC 주소```, ```2) 프레임이 도착한 인터페이스```, ```3) 현재 시간```을 테이블에 저장한다.

3. 일정 시간(수명 시간)이 지난 후에도 스위치가 해당 주소를 출발지 주소로 하는 프레임을 수신하지 못하면 삭제한다.

<br><br>

#### 링크 계층 스위치의 특성
<hr style="border-top: 1px solid;"><br>

스위치를 사용하면 다음과 같은 장점이 있다.

<br>

+ 충돌 제거

+ 이질적인 링크들
  + 스위치는 링크들을 별개로 분리하므로 랜의 각 링크는 상이한 속도로 동작할 수 있으며 상이한 매체를 사용할 수 있다.
  + 따라서 스위치는 기존 장비와 새로운 장비를 함께 사용할 수 있다.

+ 수월한 네트워크 관리 

<br><br>

#### 스위치 vs 라우터
<hr style="border-top: 1px solid;"><br>

+ 스위치 장단점
  + 플러그 앤 플레이 장치
  + 높은 패킷 여과 및 전달률
  + 토폴로지가 스패닝 트리로 제한
  + 대규모 스위치는 상당한 양의 ARP 트래픽 처리
  + 브로드캐스트 트래픽 폭주에 대비한 방안 없음

<br>

+ 라우터 장단점
  + 패킷은 출발지와 목적지 간의 최상의 경로를 사용 가능
  + 인터넷 토폴로지가 자유롭게 구축될 수 있음
  + 2계층에서의 브로드캐스트 트래픽의 폭주에 대비한 방화벽 보호 기능
  + 3계층 필드까지 처리해야 하므로 스위치보다 패킷당 처리 시간이 더 큼

<br>

![image](https://user-images.githubusercontent.com/52172169/180391340-0e40b681-fcdd-4e9a-97f5-d0044b724a87.png)

<br>

일반적으로 소규모 네트워크에서는 스위치, 큰 네트워크에서는 라우터도 포함한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/180391510-857c731c-5886-446e-bfed-2f814b8cf005.png)

<br><br>

### VLAN
<hr style="border-top: 1px solid;"><br>

VLAN을 지원하는 스위치는 하나의 물리적 근거리 네트워크 기반구조 상에서 여러 개의 가상 근거리 네트워크들을 정의할 수 있게 한다.

VLAN에 속한 호스트들은 마치 스위치에 자신들만 연결된 것처럼 서로 통신한다.

포트 기반 VLAN에서는 네트워크 관리자가 스위치 포트(인터페이스)를 그룹으로 나눈다.

각 그룹은 하나의 VLAN을 구성하며, 한 VLAN의 포트들은 하나의 브로드캐스트 도메인을 형성한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/180393057-8de79d1e-7ee0-4b81-82c6-c775c4163cf3.png)

<br>

그러나 2개의 VLAN을 완벽하게 격리함으로써 문제가 발생했는데, 두 VLAN간 통신을 어떻게 하는가이다.

이 문제는 VLAN 스위치 포트(포트 1)를 외부 라우터에 연결하고 이 포트를 두 VLAN 그룹에 모두 속하게 구성하면 된다.

이 경우 두 그룹은 같은 물리 스위치를 공유하더라도 논리적 구성은 두 그룹이 라우터를 통해 별도의 스위치를 갖는 것처럼 된다.

<br>

스위치에는 VLAN 스위치와 라우터를 모두 포함시킴으로써(별도의 외부 라우터가 필요 없도록) 네트워크 관리자가 이러한 구성을 쉽게 할 수 있게 해준다.

<br>

2개의 VLAN이 있는 두 VLAN 스위치의 연결하는 방법은 아래와 같다.

![image](https://user-images.githubusercontent.com/52172169/180429999-d57bc4b2-4082-4df2-9d54-111ac581358c.png)

<br>

a 방법은 단순히 각 스위치의 포트 하나를 왼쪽 VLAN 스위치의 VLAN 그룹 중 하나에 속하게 하고 이들 포트를 연결한 것으로, 이 방법은 두 스위치를 연결하기 위해서 N개의 VLAN이 있는 경우 스위치마다 N개의 포트들이 필요하기 때문에 확장 문제가 발생한다.

좀 더 확장 가능한 방법으로 b처럼 VLAN 트렁킹이 있다.

b의 VLAN 트렁킹 방법에서는 스위치마다 하나의 특수 포트가 2개의 VLAN 스위치를 연결하는 **트렁크 포트**로 구성되어 있다.

**트렁크 포트**는 모든 VLAN에 속하며, 한 VLAN에서 전송한 프레임들을 트렁크 링크를 통해 다른 스위치로 전달해 준다.

<br>

위에서는 포트 기반 VLAN을 설명한 것이며, VLAN은 몇 가지 다른 방식으로 정의될 수 있다. 

<br><br>
<hr style="border: 2px solid;">
<br><br>
