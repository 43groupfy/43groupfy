---
title: Network Layer Data Plane
date: 2022-07-13-12:24  +0900
categories: [Study, Computer Network]
tags: [Network Layer]
---

# 네트워크 계층 개요
<hr style="border-top: 1px solid;"><br>

![네트워크 계층](https://user-images.githubusercontent.com/52172169/178651428-21b49494-6ddc-4130-895d-653db3e3d3b5.png)

<br>

위의 그림은 H1과 H2의 경로상에 여러 라우터와 두 호스트 H1과 H2로 이루어진 간단한 네트워크를 보여준다.

각 라우터의 데이터 평면 역할은 입력 링크에서 출력 링크로 데이터그램을 전달하는 것이다.

네트워크 제어 평면의 근본적 역할은 데이터그램이 송신 호스트에서 목적지 호스트까지 잘 전달되게끔 로컬, 퍼 라우터 포워딩을 조정하는 것이다.

**라우터는 애플리케이션 계층과 트랜스포트 계층을 지원하지 않으므로 프로토콜 스택에서 네트워크 계층의 상위 계층은 존재하지 않는다.**

<br><br>

## 포워딩과 라우팅: 데이터 평면과 제어 평면
<hr style="border-top: 1px solid;"><br>

네트워크 계층의 근본적 역할은 매우 단순하다. 즉, 송신 호스트에서 수신 호스트로 패킷을 전달하는 것이다.

이를 위한 두 가지 네트워크 계층의 중요 기능을 아래와 같이 정의한다.

<br>

+ 포워딩(전달)
  + 패킷이 라우터의 입력 링크에 도달했을 때 라우터는 그 패킷을 적절한 출력 링크로 이동시켜야 한다.
  + 포워딩은 **데이터 평면**에 구현된 하나의 기능(가장 보편적이고 중요한 기능)이다.

<br>

+ 라우팅
  + 송신자가 수신자에게 패킷을 전송할 때 네트워크 계층은 패킷 경로를 결정해야 한다.
  + 이러한 경로를 계싼하는 알고리즘을 라우팅 알고리즘이라 한다.
  + 네트워크 계층의 **제어 평면**에서 실행된다. 

<br>

**포워딩**은 매우 짧은 시간 (보통 몇 나노초) 단위를 갖기에 대표적으로 **하드웨어**에서 실행된다.

반면에, **라우팅**은 네트워크 전반에 걸쳐 출발지에서 목적지까지 데이터그램의 종단간 경로를 결정하는 것이므로, 라우터는 더 긴 시간 (보통 초) 단위를 갖기에 **소프트웨어**에서 보통 실행된다.

운전에 비유하면, A지역에서 B지역으로 갈 때 많은 교차로를 지나게 된다.

이 때 **포워딩**은 한 교차로를 지나는 과정이라 볼 수 있는데 즉, 차가 하나의 도로에서 교차로로 들어서면 교차로를 떠나 어떤 도로로 들어설지를 결정한다.

**라우팅**은 A지역에서 B지역으로의 여행을 계획하는 과정이라 볼 수 있는데 즉, 여행을 시작하기 전에 운전자는 지도를 보면서, 일련의 교차로에 연결된 도로에서 이용 가능한 경로를 선택하는 것이다.

<br>

네트워크 라우터에서 필수 불가결한 요소는 **포워딩 테이블**이다.

**라우터는 도착하는 패킷 헤더의 필드 값을 조사하여 패킷을 포워딩한다.**

이 값을 라우터의 **포워딩 테이블**의 내부 색인으로 사용한다.

포워딩 테이블 엔트리에 저장되어 있는 헤더의 값은 해당 패킷이 전달되어야 할 라우터의 외부 링크 인터페이스를 나타낸다.

<br>

![포워딩 테이블에서 라우팅 알고리즘들의 결정값](https://user-images.githubusercontent.com/52172169/178654774-db068c2e-f5bd-4622-9966-c5d6c24d3a4e.png)

<br>

위의 그림은 그 예시다.

헤더 값이 0110인 패킷이 라우터에 도착한다.

라우터는 자신의 포딩 테이블을 보고 이 패킷에 대한 출력 링크 인터페이스를 결정한다.

헤더값이 0110이면 인터페이스 2로 전달하는 것으로 테이블에 설정되어 있는 걸 볼 수 있다.

<br>

**포워딩은 네트워크 계층 데이터 평면에 의해 실행되는 매우 중요한 기능이다.**

<br><br>

### 제어 평면: 전통적인 접근
<hr style="border-top: 1px solid;"><br>

여기서 어떻게 첫 포워딩 테이블이 구성되는가 의문이 생긴다.

중요한 문제로, 라우팅(제어 평면에서)과 포워딩(데이터 평면에서) 사이의 중요한 상호작용을 보여준다.

<br>

위의 그림에서와 같이 라우팅 알고리즘은 라우터의 포워딩 테이블의 내용을 결정한다.

**라우팅 알고리즘은 각각의 모든 라우터에서 실행되며, 라우터는 포워딩과 라우팅 기능 모두 갖고 있어야 한다.**

한 라우터의 라우팅 알고리즘 기능은 다른 라우터의 라우팅 알고리즘과 소통하며 포워딩 테이블의 값들을 계산한다.

소통은 라우팅 프로토콜에 따라 라우팅 정보에 포함된 라우팅 메시지를 교환하며 이루어진다.

<br><br>

### 제어 평면
<hr style="border-top: 1px solid;"><br>

![image](https://user-images.githubusercontent.com/52172169/178666563-0b0d9a12-c67c-42c5-8a62-965f4b16cdbc.png)

<br>

위의 그림은 물리적으로 라우터로부터 분리된 원격 컨트롤러 컴퓨터와 각각의 라우터에 의해 사용될 포워딩 테이블을 분배하는 다른 접근법을 보여준다.

원격제어가 포워딩 테이블을 계산과 배분하는 동안 라우팅 기기는 포워딩만을 수행한다.

원격 컨트롤러가 높은 신뢰성과 중복성을 갖춘 원격 데이터 센터에 설치될 수 있으며, ISP 혹은 다른 제 3자에 의해 관리될 수 있다.

<br>

라우터와 원격 컨트롤러는 포워딩 테이블과 다른 라우팅 정보들을 포함한 메시지를 교환함으로써 소통할 수 있다.

<br><br>

## 네트워크 서비스 모델
<hr style="border-top: 1px solid;"><br>

네트워크 서비스 모델은 송수신 호스트 간 패킷 전송 특성을 정의한다.

네트워크 계층에서 제공할 수 있는 서비스는 아래와 같다.

<br>

+ 보장된 전달
  + 이 서비스는 패킷이 소스 호스트에서부터 목적지 호스트까지 도착하는 것을 보장한다. 

+ 지연 제한 이내의 보장된 전달
  + 이 서비스는 패킷의 전달 보장뿐만 아니라 호스트 간의 특정 지연 제한(예: 100msec 이내) 안에 전달한다. 

+ 순서화(in-order) 패킷 전달
  + 이 서비스는 패킷이 목적이에 송신된 순서로 도착하는 것을 보장한다.

+ 최소 대역폭 보장
  + 이 서비스는 송신과 수신 호스트 사이에 특정한 비트 속도(예: 1 Mbps)의 전송 링크를 에뮬레이트한다.
  + 송신 호스트가 비트들을 특정한 비트 속도 이하로 전송하는 한, 모든 패킷이 목적지 호스트까지 전달된다.

+ 보안
  + 네트워크 계층은 모든 데이터그램들을 소스 호소트에서는 암호화, 목적지 호스트에서는 해독할 수 있게 하여 전송 계층의 모든 세그먼트들에 대해 기밀성을 제공하여야 한다. 

<br>

인터넷 네트워크 계층은 최선형 서비스를 제공한다.

최선형 서비스는 패킷을 보내는 순서대로 수신됨을 보장할 수 없을 뿐만 아니라, 목적지까지의 전송 자체도 보장될 수 없다.

종단 시스템 간 지연 또한 보장되지 않으며, 보장된 최소 대역폭도 없다.

이렇게 보면 쓸모없는 것처럼 보이고, 실제로 더 좋은 서비스 모델도 나왔으나 흥미롭게도, 적절한 대역폭이 제공되는 인터넷 기반 최선형 서비스 모델이 놀랍게도 광범위한 애플리케이션들(넷플릭스, 스카이프 등)이 실행될 만큼 ```충분히 좋다```라고 입증되고 있다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

# 라우터 내부에는 무엇이 있을까?
<hr style="border-top: 1px solid;"><br>

![라우터 구조](https://user-images.githubusercontent.com/52172169/178670771-c274f836-abad-4a2e-9258-dd4ad6d11a28.png)

<br>

일반적인 라우터 구조는 위와 같으며, 라우터의 네 가지 요소를 아래와 같이 정의한다.

<br>

+ 입력 포트
  + 라우터로 들어오는 입력 링크의 물리계층 기능을 수행한다.
  + 입력 포트는 입력 링크의 반대편에 있는 링크 계층과 상호운용하기 위해 필요한 링크 계층 기능을 수행한다.
    + 이것은 입력 및 출력 포트에서 중간 상자로 표시된다. 
  + 가장 중요한 것은 **입력 포트에서 검색 기능을 수행** 하는 것이다.
    + 3번째 상자에서 발생하며, 여기서 포워딩 테이블을 참조하여 도착된 패킷이 스위칭 구조를 통해 전달되는 라우터 출력 포트를 결정한다. 
  + 제어패킷(라우팅 프로토콜 정보를 전달하는 패킷)은 입력 포트에서 라우팅 프로세서로 전달된다.

<br>

+ 스위칭 구조
  + 스위칭 구조는 라우터의 입력 포트와 출력 포트를 연결한다.
  + 라우터 내부에 포함되어 있다. 

<br>

+ 츨력 포트
  + 출력 포트는 스위칭 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리적 계층 기능을 수행하여 출력 링크로 패킷을 전송한다.
  + 링크가 양방향일 때, 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룬다.

<br>

+ 라우팅 프로세서
  + 라우팅 프로세서는 제어 평면 기능을 수행한다.
  + 기존의 라우터에서는 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산한다.
  + SDN 라우터에서 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계싼된 포워딩 테이블 항목을 수신하고 라우터의 입력 포트에 이러한 항목을 설치한다. 

<br>

라우터의 입력 포트, 출력포트, 스위칭 구조는 거의 항상 **하드웨어**로 구현되고 제어 평면 기능은 일반적으로 소프트웨어로 구현되며 라우팅 프로세서(일반적으로 기존 CPU)에서 실행된다.

<br><br>

## 입력 포트 처리 및 목적지 기반 전달
<hr style="border-top: 1px solid;"><br>

![입력 포트 프로세싱](https://user-images.githubusercontent.com/52172169/178677580-753797f9-95f2-4e14-a189-bab9e69e3ecf.png)

<br>

위의 사진은 더 자세하게 입력 처리를 보여준다.

입력 포트의 회선 종단 기능과 링크 계층 처리는 라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층을 구현한다.

입력 포트에서 수행되는 검색(Lookup)은 라우터 동작의 핵심이다.

라우터는 포워딩 테이블을 사용하여 도착 패킷이 스위칭 구조를 통해 전달되는 출력 포트를 검색한다.

포워딩 테이블은 라우팅 프로세서에서 계산되거나 업데이트되거나 원격 SDN 컨트롤러에서 수신된다.

<br>

입력 패킷을 스위칭 할 출력 포트가 각 패킷의 대상 주소를 기반으로 하는 "가장 간단한" 경우를 생각해보자.

32비트 IP 주소의 경우, 포워딩 테이블을 억지로 구현한다면 모든 가능한 목적지 주소마다 하나의 엔트리가 필요, 40억 개 이상의 가능한 주소가 있어야 하므로 불가능하다.

<br>

해결 가능한 예로, 라우터에 0에서 3까지의 네 개의 링크가 있으며 그 패킷을 다음과 같이 링크 인터페이스로 전달한다고 가정한다.

<br>

![image](https://user-images.githubusercontent.com/52172169/178684657-20064201-4d56-483f-af5a-a8014678e92d.png)

<br>

이 예에서 라우터의 포워딩 테이블에 40억 개의 엔트리까지는 필요하지 않다.

이 경우에는 아래처럼 4개의 엔트리를 갖는 포워딩 테이블이면 된다.

<br>

![image](https://user-images.githubusercontent.com/52172169/178683803-89d3c74b-6447-4a33-bf5f-b1ebb9e64362.png)

<br>

밑줄 그은 부분이 포스트픽스고, 위의 사진은 프리식스로 이런 형식의 포워딩 테이블에서 라우터는 패킷의 목적지 주소의 프리픽스를 테이블의 엔트리와 대응시킨다.

대응하는 엔트리가 존재하면 라우터는 패킷을 그 대응에 연관된 링크로 보낸다.

<br>

예를 들어, 패킷의 목적지 주소가 ```11001000 00010111 00010{110 10100001}```일 때, 이 주소의 앞 21개의 비트 프리픽스가 테이블의 첫 번째 엔트리와 대응하므로 라우터는 이 패킷을 0번 링크 인터페이스로 보낸다.

만약 앞 3개의 엔트리와 대응하지 않으면 **최장 프리픽스 매칭 규칙 (longest prefix matching rule)**을 적용한다.

즉, 테이블에서 가장 긴 대응 엔트리를 찾고, 여기에 연관된 링크 인터페이스로 패킷을 보낸다.

<br>

검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위칭 구조로 보낼 수 있다.

일부 설계에서, 다른 입력 포트로부터 패킷이 현재 스위칭 구조를 사용하고 있다면 패킷이 스위칭 구조에 들어가는 것을 일시적으로 차단할 수 있다.

차단된 패킷은 입력 포트에 대기한 다음 나중 시점에 스위칭 구조에 들어간다.

<br>

입력 포트 처리에서 "검색"이 가장 중요한 기능이지만, 다른 많은 조치를 취해야 한다.

+ 이전에 논의한 것처럼 물리 및 링크 계층 프로세싱이 되어야 한다.

+ 패킷의 버전 번호, 체크섬 및 TTL 필드를 확인하고 이후 두 필드를 다시 사용해야 한다.

+ 네트워크 관리에 사용되는 카운터(수신 된 IP 데이터그램 수)를 업데이트 해야 한다.

<br><br>

## 변환기
<hr style="border-top: 1px solid;"><br>

스위칭 구조를 통해 패킷이 입력 포트에서 출력 포트로 실제로 스위칭(즉, 전달)되므로 스위칭 구조는 라우터의 핵심이다.

세 가지 방법(메모리, 버스, 크로스바)으로 스위칭을 수행할 수 있다.

<br><br>

### 메모리 스위칭
<hr style="border-top: 1px solid;"><br>

![key](https://user-images.githubusercontent.com/52172169/178708629-f14a1fad-47b3-4247-82c5-6044873fcb29.png)

![memory switching](https://user-images.githubusercontent.com/52172169/178699436-6daf1f90-1b97-47dd-8ae4-24bae9ae826c.png)

<br>

메모리를 통한 교환은 가장 단순하고 초기의 라우터는 CPU(라우팅 프로세서)를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터이다.

입력 포트와 출력 포트는 전통적인 운영체제에서 전통적인 I/O 장치처럼 작동한다.

<br>

패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사한다.

그 다음 라우팅 프로세서는 헤더에서 대상 주소를 추출하고 포워딩 테이블에서 적절한 출력 포트를 찾은 다음 패킷을 출력 포트의 버퍼에 복사한다.

<br>

이 시나리오에서 **메모리 대역폭이 초당 최대 B인 패킷을 메모리에 쓰거나 메모리에서 읽을 수 있는 경우, 전체 전달 처리량(패킷이 입력 포트에서 출력 포트로 전송되는 총 속도)은 B/2보다 작아야 한다.**

또한 목적지 포트가 다른 경우라도 공유 시스템 버스를 통해 한 번에 하나의 메모리 I/O 작업을 수행할 수 있기 때문에 두 패킷을 동시에 전달할 수 없다.

<br><br>

### 버스 스위칭
<hr style="border-top: 1px solid;"><br>

![key](https://user-images.githubusercontent.com/52172169/178708635-f8255817-2aef-461c-991b-db7863062178.png)

![bus switching](https://user-images.githubusercontent.com/52172169/178708591-2ec6a8df-d6cc-4258-a858-895ce2f9753e.png)

<br>

이 접근 방식에서, **입력 포트는 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송**한다.

동시에 여러 패킷이 다른 입력 포트로 라우터에 도착하면 **한번에 하나의 패킷만 버스를 통과할 수 있기 때문에 하나를 제외한 모든 패킷이 대기**해야 한다.

모든 패킷이 하나의 버스를 건너가야 하므로, **라우터의 교환 속도는 버스 속도에 의해 제한**된다.

<br><br>

### 크로스바 스위칭
<hr style="border-top: 1px solid;"><br>

![key](https://user-images.githubusercontent.com/52172169/178708678-19d70070-8d88-4e09-acfb-32bb793f8172.png)

![crossbar switching](https://user-images.githubusercontent.com/52172169/178708701-0825e0b7-4387-463a-9771-da5cef73bc30.png)

<br>

공유 버스의 대역폭 문제를 극복하는 한 가지 방법은 이전의 다중 프로세서 컴퓨터 구조에서 프로세서를 인터커넥션하는 데 사용된 것과 같은 보다 복잡한 인터커넥션 네트워크를 사용하는 것이다.

크로스바 스위치는 N개의 입력 포트를 N개의 출력 포트에 연결하는 2N버스로 구성된 인터커넥션 네트워크이다.

각 수직 버스는 교차점에서 각 수평 버스와 교차하며 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있다.

<br>

패킷이 포트 A에 도착하여 포트 Y로 전달되어야 하는 경우, 스위치 컨트롤러는 A와 Y 버스들과 포트 A의 교차로에서 교차점을 닫고, 버스로 패킷을 전달한다. 

이는 Y 버스에서만 픽업한다.

A에서 Y로, B에서 X로의 패킷들은 다른 입출력 버스를 사용해 B 포트에서의 패킷은 동시에 X로 전달될 수 있다.

<br>

따라서 이전 2개의 스위칭 방식과는 달리 **크로스바 스위치는 여러 패킷을 병렬로 전달할 수 있다.**

크로스바 스위치는 출력 포트로 전달되는 패킷을 다른 패킷이 현재 해당되는 출력 포트로 전달되지 않는 한 해당 출력 포트에 도달하는 것을 차단하지 않는다.

그러나 두 개의 서로 다른 입력 포트에서 나오는 두 개의 패킷이 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력포트에서 기다려야 한다.

<br><br>

## 출력 포트 프로세싱
<hr style="border-top: 1px solid;"><br>

![출력 포트 프로세싱](https://user-images.githubusercontent.com/52172169/178742731-91b9a5ae-dd74-4b03-ac47-6587d1ee6167.png)

<br>

출력 포트 프로세싱은 출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송한다.

여기에는 전송을 위한 패킷 선택 및 대기열 제거, 필요한 링크 계층 및 물리계층 전송 기능을 수행하는 것이 포함된다.

<br><br>

## 어디에서 큐잉이 일어날까?
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 교차로 입구 차 
  + 패킷
  + 대기열
  + 대기열 증가
  + 라우터 메모리 소모 -> 메모리 부족
  + 패킷 손실
  + 라우터 내부

<br>

교차로 입구에 차가 대기하는 대기열과 같이, 패킷 큐는 입력 및 출력 포트 모두에서 형성될 수 있다. 

즉, 패킷이 입력 포트와 출력 포트의 큐에서 대기하는 상태를 큐잉 지연이라 한다.

이 대기열이 증가를 하게 되면 라우터의 메모리가 소모를 하게 되어 패킷을 저장할 메모리가 부족하게 되면 패킷 손실이 발생하게 되는 것이다.

패킷 손실 및 폐기가 실제로 발생하는 곳은  라우터 내부에서 발생한다.

<br><br>

### 입력 큐잉
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 스위칭 구조
  + 한번에 하나
  + 지정된 출력포트
  + HOL(Head Of Line) 차단
  + 회선 앞쪽 다른 패킷
  + 입력 큐 대기 패킷
  + 스위칭 구조를 통한 전송

<br>

스위칭 구조는 패킷을 한번에 하나씩만 지정된 출력 포트로 전달해줄 수 있다.

<br>

![HOL 차단 및 입력 대기된 스위치](https://user-images.githubusercontent.com/52172169/178893346-ad8c15da-cd6b-4a6c-b460-3db117b55a9b.png)

<br>

HOL(Head Of The Line) 차단이란 회선 앞쪽 다른 패킷에 의해 입력 큐에서 대기 중인 패킷은 지정된 출력 포트가 사용 중이 아니더라도 스위칭 구조를 통해 전송되기를 기다려야 한다.

<br><br>

### 출력 큐잉 
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 메모리 부족
  + drop-tail
  + 기존 패킷 폐기
  + 저장 공간 확보
  + AQM(Active Queue Management)
  + 패킷 폐기, 패킷 마킹 정책
  + AQM 알고리즘 중 RED 알고리즘
  + 패킷 중 하나는 대기 중인 출력 포트로 전송
  + 패킷 스케줄러가 결정

<br>

들어오는 패킷을 저장할 메모리가 부족할 때 패킷을 버리는 drop-tail 정책을 실행하거나, 기존의 패킷을 폐기하고 새로 들어오는 패킷을 위해 저장 공간을 확보한다.

AQM 알고리즘으로 알려진 패킷 폐기, 패킷 마킹 정책 중 RED(Random Early Detection) 알고리즘이 많이 연구되었다.

<br>

![출력 포트 큐잉](https://user-images.githubusercontent.com/52172169/178899627-cc254f17-3da8-44fb-af79-566efc799f66.png)

<br>

위의 그림을 보면 기존의 3개의 패킷인 이미 출력 포트로 전송됬고, 새로 들어오는 2개의 패킷에 대해서 이 중 하나는 대기 중인 출력 포트로 전송되는데 이를 출력 포트의 패킷 스케줄러가 전송 대기중인 패킷 중 하나를 결정한다.

<br><br>

## 패킷 스케줄링
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 라우터 큐잉 처리 방법
  + FCFS (First Come First Served)
  + FCFS == FIFO
  + 방법 2가지 
  + FIFO, Round-Robin

<br>

라우터 큐잉 처리 방법은 FCFS 즉, FIFO이며 2가지 방법으로 FIFO와 라운드 로빈이 있다.

<br><br>

### First-In-First-Out
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 도착한 순서
  + 전송 패킷 선택 

<br>

![FIFO 큐잉 개념도](https://user-images.githubusercontent.com/52172169/178901180-65675068-3f21-4ca8-8aa9-5c490ca795fb.png)

<br>

FIFO는 말 그대로 출력 링크 큐에 도착한 순서대로 출력 링크에서 전송할 패킷을 선택하는 것이다.

아래 그림은 FIFO 큐의 동작을 보여준다.

<br>

![FIFO 큐의 동작](https://user-images.githubusercontent.com/52172169/178902016-ede7420b-b261-4834-93cc-de3120831d7d.png)

<br><br>

### 우선순위 큐잉
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 우선 순위 클래스
  + 고유한 큐
  + 가장 높은 우선순위 클래스 패킷 전송
  + 동일 우선순위는 FIFO로 처리
  + 패킷 전송 시작 시 중단 없음 
  + 비 선점 우선순위 큐잉

<br>

![우선순위 큐잉 모델](https://user-images.githubusercontent.com/52172169/178903331-e34f6a3a-4110-48b2-8349-afcfff564388.png)

<br>

우선순위 큐잉은 우선 순위 클래스를 가지고 있고 각각의 고유한 큐가 있다.

가장 높은 우선순위 클래스에서 패킷을 전송하고 동일 우선순위 패킷은 FIFO 방식으로 처리한다.

패킷을 전송하기 시작하면 중간에 중단을 하지 않는데 이를 ```비 선점 우선순위 큐잉```라고 하며, 전송 중간에 우선 순위가 더 높은 패킷이 들어와도 중단하지 않는다는 것이다.

아래는 우선순위 큐의 동작이다.

<br>

![우선순위 큐의 동작](https://user-images.githubusercontent.com/52172169/178903253-81c73ce7-03ab-44a4-923d-ef0d4fab2c0e.png)

<br><br>

### 라운드로빈과 WFQ
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 클래스로 분류
  + 우선순위 존재 안함
  + 클래스 간 번갈아서 서비스 제공(순환 방식)
  + WFQ 규칙
  + 순환 방식
  + 클래스 간 다른 양의 서비스 시간 == 가중치

<br>

라운드로빈 또한 클래스로 분류를 하지만, 우선순위가 존재하지 않고 클래스 간 번갈아가면서 서비스를 제공한다.

아래는 두 개의 클래스 라운드 로빈의 동작을 나타낸 그림이다.

<br>

![두 개의 라운드 로빈 클래스 동작](https://user-images.githubusercontent.com/52172169/178906630-e7d00644-2a2a-4feb-9e9f-de742e361555.png)

<br>

라우터의 라운드 로빈 큐잉의 일반적인 형태는 WFQ(Weighted Fair Queueing)이다.

WFQ 규칙도 마찬가지로 순환 방식이나 차이점은 클래스 간 다른 양의 서비스 시간 즉, 가중치를 설정한다는 것이다.

아래는 WFQ를 나타낸 것이다.

<br>

![WFQ](https://user-images.githubusercontent.com/52172169/178907654-50e16a17-75b5-4833-8cd7-2f402eb85674.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>

# 인터넷 프로토콜

## IPv4 데이터그램 형식
<hr style="border-top: 1px solid;"><br>

![IPv4 Datagram Format](https://user-images.githubusercontent.com/52172169/178907917-4e4cc10f-b1fe-435a-8273-c240f3f781ba.png)

<br>

IPv4 데이터그램 주요 필드는 아래와 같다.

<br>

+ 버전 번호 
  + 4비트의 IP 프로토콜 버전

+ 헤더 길이
  + 헤더에는 가변 길이 옵션이 포함되므로, 4비트로 실제 페이로드가 시작되는 곳을 결정.
  + 대체로 헤더 길이는 20바이트(대부분 IPv4 데이터그램은 옵션을 포함하지 않음)

+ 서비스 타입(TOS)
  + 서로 다른 유형의 IP 데이터그램을 구별한다.
  + 예를 들면, 실시간 데이터그램(전화 통신 애플리케이션 등)과 비실시간 트래픽(FTP)를 구분하는데 유용하다.
  + 사용되지 않는다. (그래서 다른데 쓰인다고 한다.)

+ 데이터그램 길이
  + 바이트로 계산한 IP 데이터그램(헤더와 데이터)의 전체 길이
  + 16비트이므로 IP 데이터그램의 최대 길이는 65535바이트이나, 1500바이트보다 큰 경우는 거의 없음

+ 식별자, 플래그, 단편화 오프셋
  + 단편화에 쓰인다.

+ TTL
  + 네트워크에서 데이터그램이 무한히 순환되지 않도록 한다.
  + 라우터가 데이터그램을 처리할 때마다 감소한다.
  + 0이 되면 라우터가 데이터그램을 폐기한다.

+ 프로토콜
  + 일반적으로 IP 데이터그램이 최종 목적지에 도착했을 때만 사용된다.
  + 목적지의 전송 계층의 특정 프로토콜을 명시한다.

+ 헤더 체크섬
  + 라우터가 수신한 IP 데이터그램의 비트 오류를 탐지한다. 
  + 라우터는 수신한 각 IP 데이터그램마다 헤더 체크섬을 계산하고 헤더 체크섬 필드 값과 비교하여 다르면 폐기한다.

+ 데이터(페이로드)
  + 목적지에 전달하기 위해 전송 계층 세그먼트(TCP나 UDP)를 포함하지만 ICMP 메시지와 같은 다른 유형의 데이터를 담기도 한다. 

<br>

IP 데이터그램은 총 20바이트의 헤더(보통 옵션이 없다)를 가지며 데이터그램이 TCP 세그먼트를 전송한다면 단편화가 되지 않은 각 데이터그램은 응용 계층의 메시지와 더불어 총 40바이트의 헤더 (IP헤더 20바이트와 TCP 헤더 20바이트)를 전송한다.

<br><br>

## IPv4 데이터그램 단편화
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 링크 계층 프라임이 전달할 수 있는 최대 데이터의 양 MTU
  + 링크마다 다른 링크 계층 프로토콜 사용과 각각 다른 MTU
  + 단편화(fragment)
  + 큰 IP 데이터그램을 링크의 MTU에 맞춰 분할
  + 재결합
  + 식별자, 플래그, 단편화 오프셋 필드
  + 송신 시 식별자 번호 증가
  + 마지막 데이터그램 플래그는 0, 나머지는 1
  + 오프셋 필드는 조각의 위치 명시

<br>

링크 계층 프라임이 전달할 수 있는 최대 데이터 양을 MTU라 하는데, 링크마다 다른 링크 계층 프로토콜을 가질 수 있고 각각 MTU가 다르다.

이런 환경에서 어떻게 IP 데이터그램이 링크 계층 페이로드인 프레임에 맞출 수 있는가에 대한 해결책으로 **단편화**가 있다.

**단편화**는 큰 IP 데이터그램을 작은 크기의 여러 개의 데이터그램으로 분할하는 것을 뜻한다.

<br>

데이터그램을 수신받으면 재결합을 해야하는데 사용되는 필드는 식별자, 플래그, 단편화 오프셋 필드이다.

송신자가 데이터를 송신할 때마다 식별자 번호를 증가시키고, 플래그 값은 마지막 데이터만 0으로 하고 나머지는 1로 설정한다.

오프셋 필드는 원본 데이터 내의 조각의 위치를 명시한다.

<br>

![IP 단편화와 재결합](https://user-images.githubusercontent.com/52172169/178916551-5ce15b8a-957a-47df-8d5a-ea0f357e8e25.png)

<br>

MTU가 1500바이트인데, 데이터그램이 4000바이트(IP헤더 20바이트 + 데이터 3980바이트)이므로 단편화를 해야 한다.

<br>

| length | ID | flag | offset |
|--------|----|------|--------|
| 4000   | X  | 0    | 0      |

<br>

위의 데이터그램을 아래와 같이 3개의 데이터그램으로 분할하여 보낸 뒤 재결합해야 한다.

offset은 1바이트 당 8비트이므로 8로 나눈 값으로 표시한다.

length는 1500 = 1480(데이터) + 20(헤더 바이트)이다.

<br>

| length | ID | flag | offset |
|--------|----|------|--------|
| 1500   | X  | 1    | 0      |

<br>

| length | ID | flag | offset |
|--------|----|------|--------|
| 1500   | X  | 1    | 185    |

<br>

| length | ID | flag | offset |
|--------|----|------|--------|
| 1040   | X  | 0    | 370    |

<br><br>

## IPv4 주소체계
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 32비트 길이 == 2^32(40억개)
  + 십진 표기법
  + 호스트와 라우터의 인터페이스
  + 고유 IP주소
  + 자동 설정
  + 서브넷
  + 서브넷 마스크
  + CIDR
  + a.b.c.d/x
  + 브로드캐스트
  + 255.255.255.255
  + 모든 호스트로 메시지 전송

<br>

IP 주소는 32비트 길이를 가지며 십진 표기법을 사용한다.

형태는 A.B.C.D로 되어 있고 각각 8비트를 십진수로 나타낸 것이다.

IP 주소는 호스트와 라우터의 인터페이스를 구분하기 위해 부여되므로 고유한 IP주소를 가지며 이는 마음대로 선택할 수 없고 서브넷이 결정한다.

<br>

![인터넷 주소와 서브넷](https://user-images.githubusercontent.com/52172169/178924264-548b9f14-a086-4086-b314-33126979e5ba.png)

<br>

위처럼 세 호스트들이 하나의 라우터 인터페이스로 연결된 네트워크는 **서브넷**이라고 한다.

<br>

![서브넷 주소](https://user-images.githubusercontent.com/52172169/178924319-3f711f3b-8d7c-4f40-bd70-76224cfa1811.png)

<br>

위 그림의 IP 형식은 서브넷 마스크라 부르는데, ```/24```는 32비트 주소의 왼쪽 24비트(223.1.1.)가 서브넷 주소라는 것을 가리킨다.

<br>

![image](https://user-images.githubusercontent.com/52172169/178933609-38916a18-1c66-4be3-bea8-eacce2165fa4.png)

<br>

인터넷 주소 할당 방식에 CIDR라는 것이 있다.

```a.b.c.d/x```로 표기하며 ```/x```는 앞의 prefix의 비트수를 뜻하며 MSB(최상위 비트)를 의미한다.

이전에는 클래스 주소체계가 있었으며 네트워크 주소 부문을 8,16,24비트로 구분하여 A,B,C클래스로 구분하였다.

<br>

IP 주소의 또 다른 형태인 브로드캐스트 주소로 ```255.255.255.255```가 있다.

브로드캐스트 주소로 메시지를 보내면 같은 서브넷에 있는 모든 호스트로 메시지를 전송해준다. 

<br><br>

### 주소 블록 흭득
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + ISP 주소 블럭
  + 분할
  + ICANN

<br>

ISP는 주소 블럭을 할당을 받는데 이 할당 받는 주소에서 기관은 서브넷에서 사용하기 위한 IP 주소 블럭을 얻을 수 있다.

예를 들면, ISP가 할당받은 주소블럭은 아래와 같다.

<br>

![ISP의 블록](https://user-images.githubusercontent.com/52172169/179146681-331b14cd-edcd-4faa-a77d-650c7dcd8c3a.png)

<br>

이 할당받은 블록으로 8개의 조직을 지원할 수 있다.

<br>

![ISP의 블록2](https://user-images.githubusercontent.com/52172169/179146796-3b77060a-8abc-4843-87df-dc00cabaaa5e.png)

<br>

ISP로부터 주소 블록을 얻는 것도 방법이지만, 다른 방법으로 ISP도 마찬가지로 블록을 얻는 곳이 있다.

ICANN에서 ISP로 블록을 제공해주는데 여기서 할당받을 수 도 있다.

<br><br>

### 호스트 주소 흭득: DHCP
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + DHCP(동적 호스트 구성 프로토콜)
  + 네트워크 자동 설정 및 연결
  + 플러그 앤 플레이 프로토콜
  + 클라이언트/서버 프로토콜
  + UDP 67번 포트
  + yiaddr
  + DHCPDISCOVER
  + DHCPOFFER
  + DHCPREQUEST
  + DHCPACK

<br>

호스트가 주소를 흭득하는 방법으로 수동으로 설정하는 대신에 자동으로 설정해주는 DHCP(동적 호스트 구성 프로토콜)가 있다.

DHCP는 자동으로 네트워크를 호스트와 연결해준다. (연결되기 위한 IP주소, 서브넷 마스크, 디폴트 게이트웨이 등을 설정해준다.)

이를 플러그 앤 플레이(plug-and-play) 프로토콜이라고도 한다.

<br>

또한 DHCP는 클라이언트/서버 프로토콜로 DHCP 기능을 사용하기 위해선 DHCP 서버가 서브넷 안에 위치하거나 해당 네트워크에 대한 DHCP 서버 주소를 알려줄 DHCP 에이전트가 필요하다.

<br>

![DHCP 서버와 클라이언트](https://user-images.githubusercontent.com/52172169/179152258-c52bb712-ef26-4945-b4ec-f385733172e7.png)

<br>

![image](https://user-images.githubusercontent.com/52172169/179152510-d846c0e5-c5ba-4ae3-9e9f-18c1d0b0ffaf.png)

<br>

yiaddr은 새 클라이언트에 할당될 주소이다.

+ DHCPDISCOVER
  + 클라이언트가 UDP 67번으로 발견 메시지를 보내는데 출발지 주소는 0.0.0.0, 목적지 주소는 브로드캐스트 주소로 설정하여 링크 계층으로 데이터그램을 전송한다. 

+ DHCPOFFER
  + DHCP서버가 발견 메시지를 수신받고 마찬가지로 브로드캐스트 주소로 제공 메시지를 전송한다.

+ DHCPREQUEST
  + 여러 DHCP 서버 중 최적의 서버를 클라이언트가 선택하여 요청 메시지를 보낸다.

+ DHCPACK
  + 서버는 DHCP 요청 메시지에 대해 ACK 메시지를 전송한다.

<br><br>

## 네트워크 주소 변환 (NAT)
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 사설망
  + 글로벌 인터넷
  + 홈 네트워크
  + 글로벌 인터넷과의 송수신
  + NAT
  + NAT 변환 테이블

<br>

![NAT](https://user-images.githubusercontent.com/52172169/179154251-9fa7f6b5-b9a8-426c-ae15-6e26887fdd20.png)

<br>

홈 네트워크는 사설 네트워크, 사설망이라 할 수 있는데 사설망이 글로벌 인터넷과 통신을 하기 위해선 이 주소들(사설망)을 사용할 수 없다.

이를 해결하기 위해 NAT (네트워크 주소 변환)이 있다. 

위의 그림으로 보면 홈 네트워크 ```10.0.0.1```에서 웹서버 ```128.119.40.186:80```으로 데이터그램을 전송한다 가정한다.

먼저 NAT 기능이 있는 라우터에 데이터그램이 도착하면, NAT 테이블에 홈 네트워크 IP와 출발 포트번호(3345)를 작성하고 WAN쪽 IP 주소 ```138.76.29.7```와 새로운 출발 포트번호 ```5001```를 NAT 테이블에 작성하고 이 IP주소와 포트번호로 변경한다.

다시 웹서버에서 NAT 라우터로 데이터그램이 도착하면 다시 NAT 테이블을 확인하고 홈 네트워크 ```10.0.0.1:3345```로 데이터그램을 전달한다.

<br><br>

## IPv6
### IPv6 데이터그램 포맷
<hr style="border-top: 1px solid;"><br>

![IPv6 Datagram Format](https://user-images.githubusercontent.com/52172169/179158022-392184c8-5f53-48a7-9647-ac8e4c4aab74.png)

<br>

IPv6의 데이터그램 포맷은 위와 같으며, IPv4에서 변화된 부분은 아래와 같다.

+ 확장된 주소 기능
  + 기존 32비트에서 128비트로 확장되었으므로 IP주소가 고갈되는 일은 발생하지 않는다.

+ 간소화된 40바이트 헤더
  + IPv4의 많은 필드가 생략되거나 옵션으로 남겨졌다.
  + 40바이트 고정 길이 헤더는 라우터가 IP 데이터그램을 더 빨리 처리하게 해준다.

+ 흐름 라벨링
  + 정의하기 어려운데 RFC 2460은 ```비 디폴트 품질 서비스나 실시간 서비스와 같은 특별한 처리를 요청하는 송신자에 대해 특정 흐름에 속하는 패킷 레이블링```을 가능하게 한다고 설명한다. 

<br>

IPv4의 데이터그램 형식과 비교해보면 많이 간소화되었다. 

+ 버전
  + IP 버전 번호를 인식하며, 값은 6이고 4로 바꾼다하더라도 IPv4로 인식되지 않는다.

+ 트래픽 클래스
  + IPv4의 TOS 필드와 비슷한 의미로 만든 8비트 필드로 흐름 내의 특정 응용 데이터그램에 우선 순위를 부여하는데 사용된다.

+ 페이로드 길이
  + 16비트로 고정 길이 40바이트 패킷 헤더 뒤에 나오는 바이트 길이를 뜻하고 부호 없는 정수이다.

+ 다음 헤더
  + 데이터그램의 내용이 전달될 프로토콜(TCP 또는 UDP)을 구분한다.

+ 홉 제한
  + 라우터가 데이터그램을 전달할 때마다 1씩 감소한다.
  + 홉 제한 수가 0보다 작아지면 데이터그램을 버린다.

<br>

없어진 필드는 아래와 같다.

+ 단편화/재결합
  + IPv6에서는 라우터에서 데이터그램이 너무 크다고해서 단편화(분할)를 하지 않고 패킷이 크다는 의미의 ICMP 메시지를 송신자에게 보낸다.
  + 송진자는 수신하면 데이터그램 크기를 줄여서 보낸다.
  + 단편화와 재결합은 시간이 걸리므로 라우터에서 이 기능을 삭제하고 종단 시스템이 하도록 하는 것이 네트워크에서 IP 전달 속도를 증가시킨다.

+ 헤더 체크섬
  + 트랜스포트 계층(TCP, UDP)과 데이터 링크 프로토콜(이더넷)에서 이미 수행하므로 불필요하다고 판단해서 없앴다고 한다.
  + 즉, IP 패킷의 빠른 처리가 주요 관심이 된 것이다.

<br><br>

### IPv4에서 IPv6로의 전환
<hr style="border-top: 1px solid;"><br>

+ 키워드
  + 터널링

<br>

IPv4에서 IPv6로의 전환에는 일단 "플래그 데이"를 선언하는 방법이 있는데 인터넷 장비를 모두 끄고 시간과 날짜를 정해 IPv6로 시스템으로 업그레이드 하는 것이고, 두 번째로 "터널링"이 있다.

터널링은 그림으로 보면 아래와 같다.

<br>

![Tunneling](https://user-images.githubusercontent.com/52172169/179161909-fce9e4d1-21a4-403c-b86a-e38984c23e07.png)

<br><br>
<hr style="border: 2px solid;">
<br><br>
