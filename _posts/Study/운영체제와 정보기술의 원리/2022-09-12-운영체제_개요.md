---
title: 2장 운영체제 개요
date: 2022-09-12 15:00 +0900
categories: [Study, OS]
tags: [운영체제와 정보기술의 원리]
---

## 운영체제의 정의
<hr style="border-top: 1px solid;"><br>

운영체제는 하드웨어 바로 위에 있는 **소프트웨어**로, 운영체제가 없으면 컴퓨터는 단지 고철 덩어리에 불과하다.

컴퓨터를 사용하려면 운영체제가 반드시 필요하고, 컴퓨터를 키면 운영체제도 동시에 실행이 되며, **소프트웨어가 실행이 되려면 메모리에 저장**되어야 한다.

운영체제는 매우 큰 소프트웨어이므로, 한정된 메모리를 낭비하지 않기 위해선 필수적인 부분만 메모리에 상주해야 한다.

이 필수적인 부분은 **커널**이라고 하며, 커널은 **운영체제 코드 중에서도 핵심**이라고 볼 수 있다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 운영체제의 기능
<hr style="border-top: 1px solid;"><br>

운영체제는 사용자에게는 편리한 인터페이스, 환경을 제공하고 하드웨어에는 사용자가 직접 다루기 힘든 것을 관리하는 관리자 역할을 한다.

그리고 운영체제의 핵심 기능은 자원을 **효율적**으로 관리하는 기능이다.

여기서 자원이란 하드웨어 자원과 소프트웨어 자원을 모두 포함한다.

<br>

효율적으로 관리하는 것 동시에 **형평성있게 관리**하는 것도 중요한 기능이다.

효율적인 **관리자 역할** 뿐만 아니라 다른 사용자나 프로그램이 불이익을 당하지 않도록 하는 **균형자 역할**도 해야 한다.

즉, **효율성이 가장 큰 목표**이나 **형평성도 고려**해야 한다는 것이다.

<br>

마지막 기능은 사용자와 자신을 보호하는 기능이다.

악의적인 사용자가 악의적인 행위를 하지 못하도록 **보안 및 보호 기능**을 수행한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 운영체제의 분류
<hr style="border-top: 1px solid;"><br>

운영체제는 단일작업용 운영체제와 다중작업용 운영체제로 구분하고, 최근의 PC들은 다중작업용 운영체제이다.

**단일작업용 운영체제**는 **한번에 하나의 프로그램만 실행**시킬 수 있는 것을 뜻하며, 옛날의 DOS가 있다.

**다중작업용 운영체제**는 현대의 MS 윈도우라 볼 수 있으며, **동시에 여러 프로그램을 실행시킬 수 있는 것**을 뜻한다.

<br>

다중작업용 운영체제의 **주의 점**은 하나의 cpu가 **동시에 여러 프로그램을 실행시키는 것이 아니다**.

하나의 CPU가 매우 짧은 시간 단위로 쪼개서 여러 개의 프로그램을 실행하는 것으로, 한번에 하나의 프로그램을 실행하지만 처리 속도가 매우 빨라서 동시에 하는 것처럼 보이는 것이다.

이처럼 CPU의 작업 시간을 분할해서 사용하는 것을 **시분할 시스템**이라고 한다.

<br>

또한, 여러 프로그램을 동시에 실행할 때는 메모리에 동시에 올라가 있는데 이처럼 여러 프로그램을 동시에 메모리에 올려놓고 처리하는 시스템을 **다중 프로그래밍 시스템**이라 한다.

<br>

**다중작업용 운영체제**에서 여러 프로그램을 실행시킬 때, 각각의 프로그램에 입력을 하면 곧바로 결과를 화면에 보여주는데, 이를 **대화형 시스템**이라 한다.

여러 사용자가 사용하는 서버의 경우에도 각각의 사용자가 입력을 하면 곧바로 결과를 확인하므로 서버 또한 대화형 시스템이라 볼 수 있다.

<br>

또 다른 기준으로는 **단일사용자용**과 **다중사용자용**으로 구분할 수 있다.

단일사용자용 운영체제는 DOS처럼 한번에 하나의 작업만 수행할 수 있는 경우와, MS의 윈도우처럼 혼자 사용하지만 다중 작업이 가능한 경우로 구분할 수 있다.

다중사용자용 운영체제는 메일 서버나 웹 서버 등 여러 사용자가 동시에 사용 가능한 것이라 볼 수 있다.

<br>

처리 방식을 기준으로 분류할수도 있다.

**일괄처리(batch processing) 방식**은 요청된 작업을 일정량씩 가져와서 한번에 처리하는 방식으로, 처리해야 할 여러 작업의 일정량을 모아서 한꺼번에 처리한다.

단, 모든 작업을 완전히 처리해야 결과를 얻을 수 있어서, 사용자 입장에서는 **응답시간이 길다는 단점**이 있다.

<br>

**시분할 방식**은 여러 작업을 수행할 때, 컴퓨터의 작업 능력을 **일정한 시간 단위로 분할**해서 사용하는 방식이다.

일괄처리 방식보다 응답이 빠르고, 입력에 대한 응답을 거의 곧바로 얻을 수 있는 대화형 시스템이다.

<br>

마지막으로 **실시간(real time) 시스템**이 있는데, **정해진 시간 안에 반드시 처리**됨을 보장하는 시스템에서 사용된다.

즉, 일정 시간안에 처리하지 못하면 위험을 초래하거나 동작 자체가 되지 않는 시스템에서 사용된다.

두 가지로 세분화하는데, **경성(hard) 실시간 시스템**과 **연성(soft) 실시간 시스템**으로 구분한다.

**경성 실시간 시스템**은 일정 시간 내에 처리하지 못하면 **큰 위험을 초래하는 시스템**인 원자로나 로켓을 뜻한다.

**연성 실시간 시스템**은 멀티미디어 스트리밍 시스템과 같이 **데이터가 정해진 시간 단위로 전달되어야 올바른 기능을 수행할 수 있는 시스템**을 뜻한다.

<br><br>
<hr style="border: 2px solid;">
<br><br>

## 운영체제의 자원관리
<hr style="border-top: 1px solid;"><br>

**운영체제의 목적**은 **효율적인 자원 관리**이며, 자원에는 하드웨어 자원과 소프트웨어 자원이 있다.

하드웨어 자원은 CPU와 메모리 등을 뜻하고, 하나의 컴퓨터에는 하나의 CPU만 있기 때문에 여러 프로세서들이 하나의 CPU를 효율적으로 사용해야 하고, 메모리 또한 한정적이기 때문에 효율적으로 메모리를 사용하도록 관리해줘야 한다.

입출력 장치 또한 운영체제의 관리가 필요하다.

CPU와 메모리는 전원이 꺼지면 처리 중이던 정보가 모두 지워지므로, **전원이 나가도 기억해야 하는 부분**을 **입출력 장치 중 한 종류인 보조기억장치에 파일 형태로 저장**한다.

이 때, 이러한 **파일들이 저장되는 방식이나 접근 권한 등에 대해서도 운영체제의 관리가 필요**하며, 이 보조기억장치에는 대표적으로 **하드디스크**가 있다.

<br>

CPU를 관리하는 방법으로는 FCFS, Round-Robin, Priority가 있다.

**FCFS**는 FIFO와 동일한 개념으로, **온 순서대로 CPU를 사용하게 해주는 것**으로, 이 방식의 **단점**은 먼저 온 프로세스가 장기간 사용해야 되는 작업을 처리한다면 뒤에 온 짧은 시간만 사용해도 되는 프로세스가 있다면 오랫동안 기다려야 되는 비효율성이 있다.

즉, CPU 자체의 효율적인 사용 측면으로는 문제가 없으나, 전체 시스템 상으로는 비효율적인 문제를 초래할 수 있다는 것이다.

그래서 보완하는 방식으로 라운드로빈이 있다.

**라운드 로빈**은 **일정하게 고정된 CPU 사용 시간**을 정해두는 것이다.

그러므로 아무리 오래 걸리는 작업을 하더라도 일정 시간이 지나면 중지하고 나중에 다시 재개해야 한다.

**우선 순위 스케줄링**은 프로세스에 **우선순위를 부여하여 우선순위대로 사용**하는 방식이다.

<br>

**메모리** 또한 **관리**해줘야 하는데, 프로그램을 사용하려면 메모리에 올라가야 한다.

한정된 공간에 여러 프로그램을 수용하려면 메모리를 효율적으로 할당을 해줘야 하는데, 이 때 **주소를 통해 관리**를 한다.

주소를 통해 **어느 부분**에 어떤 프로그램이 적재되었는지 알 수 있으며, 프로세스 간 영역을 침범하지 않도록 **자신의 메모리에만 접근**할 수 있도록 관리할 수 있다.

**물리적 메모리를 관리하는 방식**으로 **고정분할(fixed partition)** 방식, **가변 분할(variable partition)** 방식, **가상메모리(virtual memory)** 방식이 있다.

<br>

**고정분할 방식**은 물리적 메모리를 **여러 개의 고정된 크기의 분할로 나누는 것**으로, 크기는 각각 다를 수 있으며 단점은 융통성이 없다.

크기가 고정되므로 그 크기보다 큰 프로그램은 적재가 불가능하며, 크기보다 작은 프로그램을 적재하는 경우 공간의 일부분이 남는 **내부 조각**이 생길 수 있다.

이 내부 조각은 다른 프로그램이 사용할 수도 없으므로 비효율적이다.

<br>

**가변분할 방식**은 **매 시점 프로그램 적재 시 크기에 맞게 메모리를 분할**해주는 것이다.

따라서 분할의 크기에 의해 제약되는 문제는 없으나, 여전히 물리적 메모리보다 큰 프로그램은 적재할 수 없으며 **외부 조각**은 발생할 수 있다.

외부 조각은 사용 중이진 않지만, 다른 프로그램보다 크기가 작아 프로그램을 적재하지 못하는 공간을 뜻한다.

예를 들면, 100의 크기의 프로그램이 사용 후 80 크기의 프로그램을 적재하게 된다면 20만큼의 빈 공간이 남게 되는데, 50의 크기가 필요한 프로그램이 있다면 이 공간은 충분치 못하므로 사용이 되지 않아 낭비가 된다.

가변 분할 방식은 분할의 개수와 크기가 동적으로 변하므로 관리하는 기술이 필요하다.

<br>

**가상메모리 기법**은 **물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원**한다.

물론 실행 가능한 프로그램의 크기는 가상메모리 크기에 따라 결정된다.

독립적인 주소 0번부터 시작하는 자신만의 가상메모리 주소를 가지며, 운영체제는 가상메모리와 물리적 메모리 간의 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올린다.

따라서 물리적 메모리 크기가 1기가라면 2기가 프로그램을 적재할 수 있는데, **원리**는 다음과 같다.

**프로그램 실행 시** 프로그램 전체가 사용되는 것이 아닌, **일부분만 사용**되므로 그 **일부분만을 물리적 메모리에 올리고 나머지 부분은 보조기억장치에 저장**을 해둔다.

이 보조기억장치의 영역을 **스왑 영역(swap area)**이라고 한다.

또한 가상 메모리 공간은 **페이지(page)라는 동일한 크기의 작은 단위**로 나뉘어져 있는데, 물리적 메모리와 스왑 영역에 일부분씩 저장된다.

이렇게 **동일한 단위로 메모리를 나누는 기법**을 **페이징(paging)** 기법이라 한다.

<br>

**주변장치 및 입출력 장치**는 **인터럽트**라는 **신호**를 통해 CPU에게 요청을 보낸다.

CPU는 인터럽트가 발생하면 **하던 작업을 중지**하고 **인터럽트의 종류에 따라 미리 정해진 루틴으로 인터럽트를 처리**하고 **다시 기존의 작업을 재개**한다.

**주변장치**에는 작은 CPU인 **컨트롤러**가 있고, 이 **컨트롤러가 인터럽트 신호를 CPU에게 전송**한다. 

<br><br>
<hr style="border: 2px solid;">
<br><br>
