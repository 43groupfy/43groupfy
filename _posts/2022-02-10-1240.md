---
title: "[C++] BOJ 1240 노드사이의 거리"
excerpt: "BOJ 1240 노드사이의 거리에 대한 풀이"

categories:
  - BOJ
tags:
  - [BOJ]

toc: true
toc_sticky: false

date: 2022-02-10
last_modified_at: 2022-02-10
mainfont: Bareun_hipi
---

# [C++] BOJ 1240 노드사이의 거리

## 문제

[BOJ 1240 노드사이의 거리](https://www.acmicpc.net/problem/1240)

## 풀이

트리 구조에서 임의의 두 노드 사이의 거리를 구하는 문제였다.

> 트리 : 사이클이 없고 두 노드를 잇는 길이 하나뿐인 그래프

`vector<pii> graph[1000]`에서 첫번째는 연결된 노드 번호이고 두번째는 두 노드 사이의 거리를 의미한다.

`go(s, e)`에서 BFS를 돌려서 두 노드 사이의 거리를 구해 return 해주면 된다.

## 코드

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int, int> pii;

int n, m;
vector<pii> graph[1000];
int vis[1000];

int go(int s, int e) {
    queue<pii> q;
    q.push({s, 0});
    memset(vis, 0, sizeof(vis));
    vis[s] = 1;

    while (!q.empty()) {
        pii t = q.front(); q.pop();
        if (t.first == e) return t.second;
        for(auto i : graph[t.first]) {
            if (vis[i.first]) continue;
            vis[i.first] = 1;
            q.push({i.first, t.second + i.second});
        }
    }
}

int main() {
    scanf("%d %d", &n, &m);
    for(int a, b, t, i = 0; i < n-1; i++) {
        scanf("%d %d %d", &a, &b, &t);
        a--; b--;
        graph[a].push_back({b, t});
        graph[b].push_back({a, t});
    }
    for(int a, b, i = 0; i < m; i++) {
        scanf("%d %d", &a, &b);
        a--; b--;
        printf("%d\n", go(a, b));
    }
}
```
