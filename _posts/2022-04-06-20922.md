---
title: "[C++] BOJ 20922 겹치는 건 싫어"
date: 2022-04-06 00:56:00 +0900
categories: [BOJ]
tags: [BOJ, C++, 투포인터]
---

# [C++] BOJ 20922 겹치는 건 싫어

## 문제

[BOJ 20922 겹치는 건 싫어](https://www.acmicpc.net/problem/20922)

## 풀이

투포인터 문제이다.

`go()`함수에서 왼쪽을 `i`, 오른쪽을 `ri`로 보았다.
현재 왼쪽이 `i`인 상태에서 문제 조건에 만족할 때 까지 `ri`를 최대한 오른쪽으로 옮겨준다. 이 때마다 `mx`값을 갱신해준다. 참고로 `mx`는 수열에서 같은 수가 포함된 최대 개수와 최대 개수인 수이다.

`while`문을 빠져 나왔을 때 수열에서 같은 수가 포함된 최대 개수가 `k` 이하라면 `ans`를 최대값으로 갱신시켜준다. 그리고 `arr[i]`가 최대 개수인 수와 같다면 `mx.first`를 하나 감소시켜준다.

## 코드

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef pair<int, int> pii;

int n, k;
int arr[200000];
pii mx = {0, 0};
int cnt[100001];
int ans = 0;

void go() {
    int ri = 0;
    for(int i = 0; i < n; i++) {
        while (ri < n and mx.first <= k) {
            if (cnt[arr[ri]] + 1 > k) break;
            cnt[arr[ri]]++;
            if (mx.first < cnt[arr[ri]]) {
                mx = {cnt[arr[ri]], arr[ri]};
            }
            ri++;
        }
        if (mx.first <= k) ans = max(ans, ri - i);
        if (mx.second == arr[i]) mx.first--;
        cnt[arr[i]]--;
    }
    printf("%d", ans);
}

int main() {
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i++) scanf("%d", &arr[i]);
    go();
}
```
