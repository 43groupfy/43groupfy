---
title: RxSwift6
date: 2021-1-10 10:43:59 +0800
author: grohong
categories: [RxSwift]
tags: [RxSwift6, Swift5]
image: /assets/RxSwift/RxSwift6Logo.png
---

2021년 [RxSwift6](https://github.com/ReactiveX/RxSwift/releases/tag/6.0.0)가 새로운 로고와 함께 릴리즈 됐습니다. 🚀🚀\\
변경사항에 대해서는 [해당 포스팅](https://dev.to/freak4pc/what-s-new-in-rxswift-6-2nog#new-logo)에서 살펴 볼 수 있습니다. 이번 포스팅에서는 각각의 변경사항이 어떻게 구현됐는지 알아보고, 어떻게 쓰일지 정리해 보도록 하겠습니다!

# **Swift5**

RxSwift6에서는 Swift5에서 새롭게 업데이트 된 내용이 반영되었습니다. 대표적으로 ```KeyPayh```와 ```@dynamicMemberLookup```를 이용한 property 접근으로 방식이 도입되고, ```Result``` type이 추가 되었습니다. 이번 장에서는 RxSwift6에 어떻게 Swift5를 사용하고 있는지 봐보도록 하겠습니다.

<br>

## **dynamicMemberLookup을 사용한 Binder의 자동 합성** 🌟

이번 RxSwift6에서 하이라이트라고 생각되는 변경사항입니다!\\
RxSwift5에서는 특정 객체 프로퍼티에 ```.rx```를 이용하여 **Binding**을 하여 사용하기 위해서는, **Reactive extension** 이용하여 구현해 주어야 합니다.

```swift
class MyView: UIView { 
    var title: String
    var subtitle: String?
    var icon: UIImage?
}

// implement Reactive extension
extension Reactive where Base: MyView {
    var title: Binder<String> {
       Binder(base) { base, title in 
           base.title = title
       }
    }

    var subtitle: Binder<String?> {
       Binder(base) { base, subtitle in 
           base.subtitle = subtitle
       }
    }

    var icon: Binder<UIImage?> {
       Binder(base) { base, icon in 
           base.icon = icon
       }
}

// bind view
viewModel.title.bind(to: myView.rx.title)
viewModel.subtitle.bind(to: myView.rx.subtitle)
viewModel.icon.drive(myView.rx.icon)
```

이처럼 view를 만들때마다 **Reactive extension**을 구현해주는 일은 매우 비효율적이였습니다. 하지만 RxSwift6에서는 Swift5의 ```@dynamicMemberLookup```를 사용하여 자동으로 **Reactive extension**을 구현해 주도록 하였습니다.

![```@dynamicMemberLookup```](/assets/RxSwift/ReactiveExtension.jpg)

위 사진 처럼 RxSwift6에서는 따로 작업을 하지 않아도 바로 ```.rx```로 **Binder**를 볼 수 있습니다! 👍

```@dynamicMemberLookup```은 Swift4.2에서 처음으로 소개되었습니다. **class**나 **struct**에서 property를 존재 여부와 상관없이 ```subscript```로 접근가능 하도록 구현할 수 있습니다. 하지만 Swift5.1에서는 ```KeyPath```를 이용해 property을 랩핑하여 접근가능 하도록 구현할 수 있습니다. ([Key Path Member Lookup](https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md))

RxSwift5의 ```Reactive```를 보면 다음과 같이 ```Base```만 Generic으로 받고, 나머지는 extension으로 Binding을 구현하도록 되었습니다..

```swift
// RxSwift5
public struct Reactive<Base> {
     /// Base object to extend.
    public let base: Base

    /// Creates extensions with base object.
    ///
    /// - parameter base: Base object.
    public init(_ base: Base) {
        self.base = base
    }
}
```

하지만 RxSwift6에서는 ```@dynamicMemberLookup```을 이용해 ```Reactive```를 구현하여 따로 extension으로 작업하지 않더라도, ```KeyPath```를 이용하여 view의 property에 Binding을 할 수 있도록 구현 되었습니다. 🤝

```swift
// RxSwift6
@dynamicMemberLookup
public struct Reactive<Base: AnyObject> {
    /// Base object to extend.
    public let base: Base

    /// Creates extensions with base object.
    ///
    /// - parameter base: Base object.
    public init(_ base: Base) {
        self.base = base
    }

    public subscript<Property>(dynamicMember keyPath: ReferenceWritableKeyPath<Base, Property>) -> AnyObserver<Property> {
        return AnyObserver { [weak base] event in
            guard let base = base,
                  case .next(let value) = event else { return }

            base[keyPath: keyPath] = value
        }
    }
}
```


이를 이용하여 RxSwift6에서는 **Reactive extension**을 이용해 각각의 view에서 구현해줘야 할 반복적인 작업을 ```KeyPath```를 이용하여 자동으로 처리할 수 있도록 구현 할 수 있었습니다.

<br>

## **Single의 구현을 Swift의 Result를 사용하도록 변경**

RxSwift에서 [Single객체](https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Traits.md#single)는 <ins>**elements** 와 **error**만 방출하는 Observable 객체</ins>입니다.

RxSwift5에서는 Single객체를 구현하기 위해 **elements** 와 **error**를 표현할 type이 필요했습니다. 이는 ```SingleEvent```라는 enum으로 구현되었습니다.

```swift
// RxSwift5

public enum SingleEvent<Element> {
    /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)
    case success(Element)

    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
    case error(Swift.Error)
}
```

하지만 Swift5에서 ```Result```라는 새로운 type이 소개 되었습니다. Result type은 **success** 와 **failure** 케이스가 있는 enum으로 구현되었습니다. 이는 위의 ```SingleEvent```와 똑같은 형태이기 때문에 RxSwift6에서는 ```SingleEvent```를 ```Result```로 ```typealias``` 하여 사용하게 되었습니다.

```swift
// RxSwift6

public typealias SingleEvent<Element> = Result<Element, Swift.Error>
```

<br>

## **distinctUntilChange(at:)연산자에서 Key Path 지원**

**Swift5.2**에서부터 Keypath type을 이용해 closure의 표현을 간단하게 할 수 있습니다.\\
RxSwift6에서도 ```distinctUntilChange(at:)```연산자에서 Keypath를 지원하여 간단하게 표현할 수 있습니다.

```swift
// RxSwift5
myStream.distinctUntilChanged { $0.searchTerm == $1.searchTerm }

// RxSwift6
myStream.distinctUntilChanged(at: \.searchTerm)
```

이는 RxSwfit6에서 KeyPath를 지원하는 함수로 간단하게 구현 되었습니다.

```swift
public func distinctUntilChanged<Property: Equatable>(at keyPath: KeyPath<Element, Property>) -> Observable<Element> {
    self.distinctUntilChanged { $0[keyPath: keyPath] == $1[keyPath: keyPath] }
}
```

